---
title: 数据结构三之二叉搜索树的查询和插入
date: 2014-09-24 19:17:32
tags:
- 二叉树
- c++
categories:
- c++
---



有了二叉树的基础, 我们继续学习二叉搜索树.

# 二叉搜索树的定义

**二叉查找树(Binary Search Tree), 又名：二叉搜索树，二叉排序树:**
它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。

![这里写图片描述](http://img.blog.csdn.net/20170806185002946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbm9zaXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

因为具有n个结点的完全二叉树的最大高度为log2n+1, 而二叉搜索树的查询/增加的时间复杂度都是O(h), h为树的高度,所以复杂度可以看作O(logn), h越大, 复杂度越高, 所以很明显上图中的a树比b树要高效.


<!-- more -->


# **二叉搜索树的查询**
``` c++
BTN_Ptr search(BTN_Ptr btp, int key)
{
    while (btp != NULL )
    {
        if ( btp->data != key)
        {
            if ( btp->data < key )
                btp = btp->RightChild;
            else
                btp = btp->LeftChild;
        }
        else
        {
            printf("found\n");
            return btp;
        }
    }
   printf("error : not found!\n");
   return NULL;
}

```

# **二叉搜索树的插入**

``` c++
BTN_Ptr insert(BTN_Ptr &btp, int key)
{
    if (btp == NULL)
    {
        btp = new BTN;
        btp->data = key;
        btp->LeftChild = NULL;
        btp->RightChild = NULL;
        return btp;
    }
    else
    {
        BTN_Ptr saved_btp = btp;
        BTN_Ptr temp_btp = NULL;
        while ( btp != NULL)
        {
            temp_btp = btp;
            if ( key < btp->data )
                btp = btp->LeftChild;
            else
                btp = btp->RightChild;
        }
        btp = new BTN;
        btp->data = key;
        btp->LeftChild = NULL;
        btp->RightChild = NULL;
        if ( key < temp_btp->data )
            temp_btp->LeftChild = btp;
        else
            temp_btp->RightChild = btp;
        return saved_btp;
    }
}
```

