---
title: C++很基础的易混淆点二
date: 2015-12-09 13:35:25
tags:
- c++
categories:
- c++
---

### **位操作运算符的问题**
二进制的100 的第0位是 0
1(第2位)  0(第1位)  0(第0位)， 
所以把一个数的第三位进行清零、置位(把某个bit置为1)、取反的操作如下：
``` c++
#include <stdio.h>

#define Bit3 (0X01<<3)
/*对一个数的第三位进行清零、置位、取反*/
int main()
{
	int a=15 ;      // 0000 1111

	printf("原大小：%d\n", a);

	a &= ~Bit3;     //清零, 0000 0111
	printf("清零后：%d\n", a);

	a |= Bit3;     //置位, 0000 1111
	printf("置位后：%d\n", a);

	a ^= Bit3;     //取反, 0000 0111
	printf("取反后：%d\n", a);

	return 0;
}
   
```

... <!-- more -->

### **字符串分配的位置问题**
程序的存储区域分为：代码段、只读数据段、已初始化的读写数据段、未初始化的数据段、堆、栈。
1、代码段、只读数据段、已初始化的读写数据段、未初始化的数据段都属于静态区域。
2、堆内存只在程序运行时出现，一般有程序员分配和释放。
3、栈内存只在程序运行时出现，在函数内部使用的变量，函数参数以及返回值将使用栈空间。
``` c++
char* get_str()
{
    char *str = "hello"; //第一种情况：分配在静态存储区上
    //char str[] = "hello"; //第二种情况分配在栈上
    return str;
}


int main()
{
    char* p = get_str();
    // 如果是第一种情况，下述打印可以打印出正确的值；但是第二种情况打印结果是错的。
    printf("%s/n", p);
    *++p = 'a'; // 如果是第一种情况，运行时将会段错误，因为不能修改它；
    printf("%s/n", p);
    return 0;
}
```

### **复杂类型的声明和typedef定义**

 - 用变量a给出下面的定义:
一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数 int (*a[10])(int);

 - typedef表示一个长度为4的int数组;
 typedef  int  ARR[4];
 
 - typedef表示一个函数指针有一个整型参数并返回一个整型数：
 typedef int（*FUNC）（int）；