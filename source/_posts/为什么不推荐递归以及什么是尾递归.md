---
title: 为什么不推荐递归以及什么是尾递归
date: 2015-01-02 12:18:54
tags:
- 尾递归
- c++
categories:
- c++
---

# 为什么不推荐递归



递归的调试难度奇高，就决定了实际项目中很少用递归。

而且递归确实运行效率低，因为函数一层一层调用存在调用栈，

在切换到更深层的函数时要产生断点，为了保证回来时继续运行，

必须保存现在所处函数的各种状态，回来时恢复状态，这样一层层下去性能损失就不断增加。

大量开辟在栈区的内存 ，直到每一层的递归结束或整个递归结束才释放 且这个内存空间可能呈几何级数增加， 空间效率不佳， 有可能会栈溢出

# 什么是尾递归

> 要知道什么是尾递归， 首先得指到什么是尾调用


## 尾调用

尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数

<blockquote><pre><code class="language-javascript">
function f(x){
  return g(x);
}
</code></pre></blockquote>

<p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</p>

<p>以下两种情况，都不属于尾调用。</p>

<blockquote><pre><code class="language-javascript">
// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}
</code></pre></blockquote>

<p>上面代码中，情况一是调用函数g之后，还有别的操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。</p>

<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>

<blockquote><pre><code class="language-javascript">
function f(x) {
  if (x > 0) {
    return m(x)
  }
  return n(x);
}
</code></pre></blockquote>

<p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</p>



## 什么是尾递归

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

### 尾递归具体例子1 ：

<div class="para" label-module="para">线性递归:</div>
<pre class="brush: cpp">long&nbsp;Rescuvie(long&nbsp;n)&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(n&nbsp;==&nbsp;1)&nbsp;?&nbsp;1&nbsp;:&nbsp;n&nbsp;*&nbsp;Rescuvie(n&nbsp;-&nbsp;1);

}

</pre><div class="para" label-module="para">尾递归:</div>
```
long TailRescuvie(long n, long a) {

    return (n == 1) ? a : TailRescuvie(n - 1, a  *  n);

}


long TailRescuvie(long n) {//封装用的
    
    return (n == 0) ? 1 : TailRescuvie(n, 1);

}
```
<div class="para" label-module="para">当n = 5时</div>
<div class="para" label-module="para">对于线性递归, 他的递归过程如下:</div>
<div class="para" label-module="para">Rescuvie(5)</div>
<div class="para" label-module="para">{5 * Rescuvie(4)}</div>
<div class="para" label-module="para">{5 * {4 * Rescuvie(3)}}</div>
<div class="para" label-module="para">{5 * {4 * {3 * Rescuvie(2)}}}</div>
<div class="para" label-module="para">{5 * {4 * {3 * {2 * Rescuvie(1)}}}}</div>
<div class="para" label-module="para">{5 * {4 * {3 * {2 * 1}}}}</div>
<div class="para" label-module="para">{5 * {4 * {3 * 2}}}</div>
<div class="para" label-module="para">{5 * {4 * 6}}</div>
<div class="para" label-module="para">{5 * 24}</div>
<div class="para" label-module="para">120</div>
<div class="para" label-module="para">对于尾递归, 他的递归过程如下:</div>
<div class="para" label-module="para">TailRescuvie(5)</div>
<div class="para" label-module="para">TailRescuvie(5, 1)</div>
<div class="para" label-module="para">TailRescuvie(4, 5)</div>
<div class="para" label-module="para">TailRescuvie(3, 20)</div>
<div class="para" label-module="para">TailRescuvie(2, 60)</div>
<div class="para" label-module="para">TailRescuvie(1, 120)</div>
<div class="para" label-module="para">120</div>
<div class="para" label-module="para">很容易看出, 普通的<a target=_blank href="/item/%E7%BA%BF%E6%80%A7">线性</a>递归比尾递归更加消耗资源, 在实现上说, 每次重复的过程</div>
<div class="para" label-module="para">调用都使得调用链条不断加长. 系统不得不使用栈进行数据保存和恢复.而尾递归就</div>
<div class="para" label-module="para">不存在这样的问题, 因为他的状态完全由n和a保存.</div>

### 尾递归具体例子2 ：

<div class="para" label-module="para">具体事例2 快速<a target=_blank href="/item/%E6%8E%92%E5%BA%8F">排序</a>算法实施尾递归优化</div>
<pre class="brush: cpp">void&nbsp;quickSort(SqList&nbsp;*&nbsp;list&nbsp;,&nbsp;int&nbsp;low&nbsp;,int&nbsp;high)
{

&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;pivot;

&nbsp;&nbsp;&nbsp;&nbsp;while(low&lt;high)
&nbsp;&nbsp;&nbsp;&nbsp;{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pivot=Partition(list,low,high);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quickSort(list,&nbsp;low,pivot&nbsp;-&nbsp;1);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//quickSort(list,low,pivot-1);&nbsp;原递归调用

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//quickSort(list,pivot+1,high);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;low&nbsp;=&nbsp;pivot+1;&nbsp;/*尾递归*/

&nbsp;&nbsp;&nbsp;&nbsp;}

}
</pre>