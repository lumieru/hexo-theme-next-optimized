---
title: 游戏网络开发五之每个游戏开发者都需要知道的游戏网络知识
date: 2016-11-18 22:20:34
tags:
- gafferongames
categories:
- server
---


[原文出处](https://gafferongames.com/post/what_every_programmer_needs_to_know_about_game_networking/)

[译文出处](http://gad.qq.com/program/translateview/7161836)


<div class="WordSection1"><p class="MsoNormal" align="center" style="text-align: left;"><span style="font-family: 微软雅黑, sans-serif; font-size: 12pt;">翻译：黄威（横写、意气风发）</span><span style="font-family: 微软雅黑, sans-serif; font-size: 12pt;">  </span><span style="font-family: 微软雅黑, sans-serif; font-size: 12pt;">审校：艾涛（轻描一个世界）</span></p><p class="MsoNormal" style="line-height:400%"><span style='font-size:16.0pt;line-height:400%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'><b>介绍</b></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>作为一名程序员，你是否曾想过多人游戏是如何运作的呢？</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>从表面来看这是非常奇妙：两个或者更多的玩家通过网络能够拥有相同的游戏体验，就像他们确实存在于同一个虚拟世界一样。但是作为程序员，我们知道底层运行的情况与你看到的完全不同。事实证明，这完全是一种错觉，是一个精妙的戏法。你能感受到游戏中的玩家都处于同一个世界中，但其实这只是在各个时间点，你自己独有的视角与位置和其他玩家的视角与位置相似。</span></p><p class="MsoNormal" style="text-align: center; text-indent: 24pt;"><img src="http://gameweb-img.qq.com/gad/20160628/phpEw63Qf.1467079995.jpg" alt="游戏网络开发(六)：每个游戏开发者都需要知道的游戏网络知识"   /></p><p class="MsoNormal" style="line-height:400%"><span style='font-size:16.0pt;line-height:400%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'><b>对等同步</b></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>起初，网络游戏形成一个对等的网络，在这个网络中每台电脑在一个完全连接的网状拓扑结构中互相交换信息。如今在<span>RTS</span>游戏（即时战略游戏）中你仍能够看到这一模型，有趣的是，因为某种原因，可能因为它是第一种网络连接方式——大多数人仍认为游戏网络是这样运作的。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>基本思想就是在处理数据时将游戏抽象化成一系列的数据改变与一组命令消息，每一个数据改变都决定了游戏状态的演变。例如：移动单位、攻击单位、建造建筑。所有的这一切都要求网络让每一位玩家的机器都从相同的初始状态开始，并且运行完全相同的命令，数据的改变也完全相同。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>当然，这只是一个过于简单并且忽略掉了许多微妙细节的解释，但这个解释向我们解释了<span>RTS</span>游戏网络工作的基本原理。你可以点击</span><span><a rel='nofollow' href="http://www.gamasutra.com/view/feature/3094/1500_archers_on_a_288_network_.php"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'><span>这里</span></span></a></span><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>了解更多关于这个网络模型的细节。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>这看起来是如此简单而又巧妙，但是不幸的是这个模型有几个限制因素。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>首先，要想保证游戏状态完全确定是非常困难的；即每台机器都进行着相同的变动。比如说，一个单位可以在两台机器上走略微不同的道路，在一台机器上玩家更早进入战斗并反败为胜，而在另一台机器上玩家到达的更晚，然后，嗯，没有取得胜利。就像一只蝴蝶扇动了翅膀，然后在世界的另一边导致了飓风的出现，随着时间的过去，一个微小的区别会导致两边完全的不同步。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>另一个限制因素就是为了保证游戏在所有机器上表现同步，就有必要在游戏操作在设备上模拟之前进行等待，直到设备接收到了所有玩家对于那个变动的指令。这就意味着游戏中的每一个玩家的延迟都等于延迟最高玩家的延迟。<span>RTS</span>游戏通常代表性地通过立即提供音频反馈与（或是）播放过渡动画来掩盖这段延迟，但是最终真正影响游戏的操作要在这段延迟过去之后才能进行。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>最后一个限制因素就在于游戏的同步方式是通过发送改变当前状态的命令消息。为了让其正常工作就有必要让所有的玩家由同一初始状态开始游戏。通常来说，这就意味着每个玩家都要在开始游戏之前进入房间准备游戏，尽管支持让玩家随后加入游戏从技术上来说是可行的，但是由于在一场进行中的游戏中间捕获与传输一个完全确定的起始点的难度很大，所以这种情况并不常见。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>尽管有这些限制，这个模型还是很适合<span>RTS</span>游戏的，并且在现代的游戏中它仍然存在，例如“命令与征服”、“帝国时代”与“星际争霸”等。原因就是在<span>RTS</span>游戏中，游戏状态包含了成千上万的单位，并且通常游戏状态太大而不能在玩家之间交换。这些游戏别无选择，只能交换这些驱动着游戏状态改变的指令。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>但是对于其他类别的游戏，美工的状态已经改变了。所以对于确定的对等网络同步模型就讲到这里。现在让我们从<span>Doom</span>（毁灭战士）、<span>Quake</span>（雷神之锤）以及<span>Unreal</span>（魔域幻境）中看看动作类游戏的演变。</span></p><p class="MsoNormal" style="line-height:400%"><span style='font-size:15.0pt;line-height:400%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'><b>客户端<span>/</span>服务器（<span>C/S</span>结构）</b></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>在动作游戏的时代，对等同步的限制因素在<span>Doom</span>中表现得更加明显，尽管它在局域网中表现很好，但是在面对互联网中的普通用户时表现得很糟糕：</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>“虽然可以通过调制解调器将两个运行<span>DOOM</span>的设备在互联网上连接在一起，最终游戏将会变得缓慢，延迟的情况在完全不能进行游戏（例如一个<span>14.4Kbps</span>的<span>P2P</span>连接）到略微可玩（例如一个<span>28.8Kbps</span>的调制解调器运行一个压缩驱动程序）之间不等。<u>因为这些类型的连接只有边际效用，本文将只关注于网络连接。</u>（</span><span><a rel='nofollow' href="http://www.faqs.org/faqs/games/doom/howto-tcp/#ixzz0daOnpBYn"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>faqs.org</span></a></span><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>）”</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>这个问题显然就是<span>Doom</span>本来就是只为局域网设计的，并且使用了前面描述的为<span>RTS</span>游戏制作的对等同步模型。每一个玩家输入的行为（关键按键等等）与其他人进行信息交换，只有在所有其他玩家的关键按键都被接收到之后，玩家才能够进行游戏画面的模拟。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>换句话说，在你能够操作、移动或是射击之前，你必须等待延迟最高的玩家进行连入。想想这上述的所谓“这些连接只有边际效用”将会导致的令人咬牙切齿的情况。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>现在的游戏局限于局域网游戏以及拥有良好连接条件的大学网络或是大公司的精英之间的游戏，为了改变这种情况，是时候改变这个模型了。这就是<span>John Carmack 1996</span>年在发布雷神之锤时所做的事情——他使用客户端<span>/</span>服务器（<span>C/S</span>结构）代替了对等同步模型（<span>P2P</span>）。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>现在，玩家们不再运行相同的游戏代码，直接地互相交换数据，如今每个玩家都是一个客户端，他们都与一台叫做<span>“</span>服务器<span>”</span>的电脑进行数据交换。现在的游戏不再有任何对于所有机器都要进行确定的要求，因为游戏实际上只存在于服务器上。每个客户端实际上都是作为哑终端，用来显示出一个游戏的近似情况，因为游戏实际上只在服务器上发生。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>在一个纯粹的客户端<span>/</span>服务器模型中你没有在本地运行游戏代码，而是将你的操作例如按键、鼠标移动、点击等发送到服务器。服务器响应并更新了虚拟世界中你的角色状态，然后将一个包含着你与你周围角色状态的数据包传回。所有客户端要做的事情就是在这些数据更新之间插入自己的数据，然后给你一种流畅移动的假象，然后，<span>boom</span>！你就有了一个联网的客户端<span>/</span>服务器游戏了。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>这是一个伟大的进步。游戏体验的质量现在取决于客户端与服务器之间的连接，而不是取决于游戏中延迟最高的玩家。这同时让玩家在游戏进行中的加入变成了可能，并且随着客户端<span>/</span>服务器结构对于每位玩家需要的平均带宽减少，游戏玩家也在逐渐增长。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>但是对于纯粹的客户端<span>/</span>服务器模型仍然存在一些问题。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>“尽管我能记得并整理出我从<span>DOOM</span>到<span>Quake</span>做出的所有关于网络的决定，结果就是尽管我为了做出一个好的网络游戏而努力着，但这些努力都是基于一个错误的基础假设。我原先的设计目标就是使延迟低于<span>200ms</span>。这样的话通过一个好的供应商数字连接到网络的人，就能有一个很好的游戏体验。很不幸，世界上百分之九十就都是通过调制解调器进行<span>SLIP</span>连接或是<span>PPP</span>连接，它们通常是通过一个糟糕拥挤的<span>ISP</span>（网络服务提供者）进行连接的。这就导致了<span>300ms</span>以上的延迟，并且这只是最低值。客户端，使用者的调制解调器，<span>ISP</span>的调制解调器，服务器，再回到<span>ISP</span>的调制解调器，使用者的调制解调器，最后再回到客户端。天呐，这真是糟透了！</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>好吧，我做了一件错误的事。我在家里都使用<span>T1</span>载体进行联网，所以我对使用<span>P2P</span>的生活并不了解，我现在就解决这个问题。”</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>问题当然就是延迟。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>接下来<span>John</span>在他发布<span>QuakeWorld</span>（雷神世界）时做的事情将永久改变这个行业。</span></p><p class="MsoNormal" style="line-height:400%"><span style='font-size:15.0pt;line-height:400%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'><b>客户端预测</b></span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>在最初的雷神之锤中，你可以明显感受到你的电脑与服务器之间的延迟。在你向前点击之后，你需要等待数据包发送至服务器然后再传回到你的电脑，然后你才能够开始移动。点击开火，然后你在射击之前同样需要等待上述延迟。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>如果你玩过任何像《使命召唤<span>4</span>：现代战争》之类的现代<span>FPS</span>游戏，你就会知道这种情况现在已经不会再出现了。那么现代<span>FPS</span>游戏到底是如何做到在多人游戏中看似消除了你自己行为的延迟呢？</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>这个问题在历史上分两个部分来解决。第一部分就是<span>JohnCarmack</span>为雷神世界开发的客户端移动预测，它后来被合并作为<span>Tim Sweeney</span>的魔域幻境网络模型的一部分。第二部分就是维尔福公司的<span>Yahn Bernier</span>为反恐精英开发的延迟补偿。在本节中，我们将主要讨论第一部分<span>——</span>如何隐藏玩家移动的延迟。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>当谈到他对于即将发布的雷神世界的计划时，<span>JohnCarmack</span>说：</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>“我们现在允许客户端预测使用者行动的结果，直到服务器传来命令式回复。这是一个非常非常大的架构变化。客户端现在需要知道物体的硬度、摩擦力、重力之类的数据。对于简洁的客户端作为终端计划我们已经不再采用了，我对此表示遗憾，但我是一个实用主义者而不是一个理想主义者。”</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>所以为了消除延迟，客户端需要比之前运行更多的代码。它现在不再是一个向服务器发送输入内容并在状态发回之前进行数据插入的哑终端，它现在能够在本地预测你的角色移动，并且对你的输入迅速做出反应，在客户端设备上为你的游戏角色运行一部分游戏代码。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>现在只要你向前点击，不需要再等待客户端与服务器之间的信息往返——你的角色立即开始向前移动。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>这种方法的难点不在于预测，因为预测就像是普通游戏代码做的那样——根据玩家的操作随时间发展游戏角色状态。难点就在于，当客户端和服务器对于游戏角色所处的位置及所做的事情有分歧时，客户端如何以服务器传来的信息为基础进行修正。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>对于这一点，你可能会想，嘿，如果你在客户端运行游戏代码——为什么不以客户端的情况作为游戏角色的标准呢。客户端可以为自己的角色运行仿真代码，并在每次发送数据包时告诉服务器现在的情况。那么问题就是，如果每个玩家都可以简单地告诉服务器“这就是我现在的情况”，那就非常容易黑进客户端进行作弊，例如作弊者可以瞬间躲开将要射向他们的子弹，或者立即传送到你身后从后方射击你。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>所以在<span>FPS</span>游戏中，尽管每个玩家在本地预测自己角色的运动，从表面上隐藏了延迟，但以服务器状态作为每个玩家角色状态的标准是绝对有必要的。就像<span>Tim Sweeney</span>在</span><span><a rel='nofollow' href="http://unreal.epicgames.com/Network.htm"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>UE</span><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'><span>网络架构</span></span></a></span><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>里写到的：“服务器才是大哥！”</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>这就是有趣的地方。如果客户端和服务器信息不一致，客户端就必须接受来自服务器的位置更新，但是由于客户端与服务器之间的延迟，这个对过去修正是必然的。举个例子，如果从客户端到服务器要消耗<span>100ms</span>，再经过<span>100ms</span>回来，那么任何服务器对于玩家角色位置的修正就会有<span>200ms</span>的延迟，这个时间是相对于客户端开始预测自己移动的时间。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>如果客户端连续接收服务器的修正更新，这就会及时拉回客户端，这就会导致客户端完全不能做任何客户端预测。怎么解决这个问题的同时仍然允许客户端进行超前预测呢？</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>解决方法就是在客户端为过去的角色状态以及本地玩家的输入创建一个循环缓冲区，然后当客户端收到一个来自服务器的修正，（首先它丢弃比服务器的修正状态更早的缓冲状态）依据玩家储存在循环缓冲区的输入对由上一次的正确状态开始到现在预测时间的状态进行重放。实际上客户端在等待接下来的情况匹配完成之前悄悄地“倒放与重放”当地的玩家角色移动的最后几帧。</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>这个方法可以让玩家看似无延迟地控制他们的角色，并且如果客户端与服务器的角色模拟代码一致的话——由于在客户端与服务器上相同的输入可以准确给出相同的结果——这就很少出现要修正的情况。这就像是<span>Tim Sweeney</span>描述的那样：</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>“<span>……</span>最好的两个世界：在所有情况下，服务器都是绝对权威。在几乎任何时间内，客户端的移动模拟都与服务器计算出的客户端移动完全相同，所以客户端的情况很少需要修正。只有在极少的情况，例如玩家被一枚火箭击中，或是撞上一名敌人，客户端的情况将被修正。”</span></p><p class="MsoNormal" style="text-indent:24.0pt"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>换句话说，只有当玩家的角色被一些外部事情影响到了玩家的输入，并且这些不能被客户端所预测时，玩家的情况需要被修正。当然，如果玩家试图作弊时亦然。</span></p><p class="MsoNormal" align="left" style="line-height: 18.4pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'> </span></p><p class="MsoNormal" align="left" style="line-height: 18.4pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:14.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333'>【版权声明】</span></p><p class="MsoNormal" align="left" style="line-height: 18.4pt; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:14.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333'>原文作者未做权利声明，视为共享知识产权进入公共领域，自动获得授权。</span></span><span style='font-size:9.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333'> </span></p><p class="MsoNormal" align="left" style="text-indent: 24pt;"><span style='font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222'> </span></p></div>                    </div>
                </div>