---
title: 网络物理模拟三之具有确定性的帧同步
date: 2017-01-22 11:13:35
tags:
- gafferongames
categories:
- server
---

[原文出处](https://gafferongames.com/post/deterministic_lockstep/)

<h1 id="Deterministic-Lockstep">Deterministic Lockstep</h1>

Keeping simulations in sync by sending only inputs

---------------

<div class="container">
<div class="row">
<div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
<h2 id="introduction">Introduction</h2>
<p>Hi, I&rsquo;m <a href="https://gafferongames.com/about">Glenn Fiedler</a> and welcome to <strong><a href="https://gafferongames.com/categories/networked-physics/">Networked Physics</a></strong>.</p>
<p>In the <a href="https://gafferongames.com/post/introduction_to_networked_physics/">previous article</a> we explored the physics simulation we&rsquo;re going to network in this article series. In this article specifically, we&rsquo;re going to network this physics simulation using <strong>deterministic lockstep</strong>.</p>
<p>Deterministic lockstep is a method of networking a system from one computer to another by sending only the <em>inputs</em> that control that system, rather than the <em>state</em> of that system. In the context of networking a physics simulation, this means we send across a small amount of input, while avoiding sending state like position, orientation, linear velocity and angular velocity per-object.</p>
<p>The benefit is that bandwidth is proportional to the size of the input, not the number of objects in the simulation. Yes, with deterministic lockstep you can network a physics simulation of one million objects with the same bandwidth as just one.</p>
<p>While this sounds great in theory, in practice it&rsquo;s difficult to implement deterministic lockstep because most physics simulations are not deterministic. Differences in floating point behavior between compilers, OS&rsquo;s and even instruction sets make it almost impossible to guarantee determinism for floating point calculations.</p>
<h2 id="determinism">Determinism</h2>
<p>Determinism means that given the same initial condition and the same set of inputs your simulation gives exactly the same result. And I do mean <em>exactly</em> the same result.</p>
<p>Not close. Not near enough. <strong>Exactly the same</strong>. Exact down to the bit-level. So exact, you could take a checksum of your entire physics state at the end of each frame and it would be identical.</p>
<video preload="auto" autoplay="autoplay" loop="loop" width="100%" controls="controls">
<source src="/img/deterministic_lockstep_1.mp4" type="video/mp4" />
</video>
<p>Above you can see a simulation that is <em>almost</em> deterministic. The simulation on the left is controlled by the player. The simulation on the right has exactly the same inputs applied with a two second delay starting from the same initial condition. Both simulations step forward with the same delta time (a necessary precondition to ensure exactly the same result) and both simulations apply the same inputs. Notice how after the smallest divergence the simulation gets further and further out of sync. This simulation is <strong>non-deterministic</strong>.</p>
<p>What&rsquo;s going on is that the physics engine I&rsquo;m using (<a href="http://www.ode.org/">Open Dynamics Engine</a>) uses a random number generator inside its solver to randomize the order of constraint processing to improve stability. It&rsquo;s open source. Take a look and see! Unfortunately this breaks determinism because the simulation on the left processes constraints in a different order to the simulation on the right, leading to slightly different results.</p>
<p>Luckily all that is required to make ODE deterministic on the same machine, with the same complied binary and on the same OS (is that enough qualifications?) is to set its internal random seed to the current frame number before running the simulation via dSetRandomSeed. Once this is done ODE gives exactly the same result and the left and right simulations stay in sync.</p>
<video preload="auto" autoplay="autoplay" loop="loop" width="100%" controls="controls">
<source src="/img/deterministic_lockstep_2.mp4" type="video/mp4" />
</video>
<p>And now a word of warning. Even though the simulation above is deterministic on the same machine, that does <em>not</em> necessarily mean it would also be deterministic across different compilers, a different OS or different machine architectures (eg. PowerPC vs. Intel). In fact, it&rsquo;s probably not even deterministic between debug and release builds due to floating point optimizations.</p>
<p>Floating point determinism is a complicated subject and there&rsquo;s no silver bullet.</p>
<p>For more information please refer to this <a href="https://gafferongames.com/post/floating_point_determinism/">article</a>.</p>
<h2 id="networking-inputs">Networking Inputs</h2>
<p>Now let&rsquo;s get down to implementation.</p>
<p>Our example physics simulation is driven by keyboard input: arrow keys apply forces to make the player cube move, holding space lifts the cube up and blows other cubes around, and holding &lsquo;z&rsquo; enables katamari mode.</p>
<p>How can we network these inputs? Must we send the entire state of the keyboard? No. It&rsquo;s not necessary to send the entire keyboard state, only the state of the keys that affect the simulation. What about key press and release events then? No. This is also not a good strategy. We need to ensure that exactly the same input is applied on the right side, at exactly the same time, so we can&rsquo;t just send &lsquo;key pressed&rsquo;, and &lsquo;key released&rsquo; events over TCP.</p>
<p>What we do instead is represent the input with a struct and at the beginning of each simulation frame on the left side, sample this struct from the keyboard:</p>
<pre><code>    struct Input
    {
        bool left;
        bool right;
        bool up;
        bool down;
        bool space;
        bool z;
    };
</code></pre>
<p>Next we send that input from the left simulation to the right simulation in a way that the simulation on the right side knows that the input belongs to frame n.</p>
<p>And here&rsquo;s the key part: the simulation on the right can only simulate frame n when it has the input for that frame. If it doesn&rsquo;t have the input, it has to wait.</p>
<p>For example, if you were sending across using TCP you could simply send the inputs and nothing else, and on the other side you could read the packets coming in, and each input received corresponds to one frame for the simulation to step forward. If no input arrives for a given render frame, the right side can&rsquo;t advance forward, it has to wait for the next input to arrive.</p>
<p>So let&rsquo;s move forward with TCP, you&rsquo;ve disabled <a href="https://en.wikipedia.org/wiki/Nagle's_algorithm">Nagle&rsquo;s Algorithm</a>, and you&rsquo;re sending inputs from the left to the right simulation once per-frame (60 times per-second).</p>
<p>Here it gets a little complicated. Since we can&rsquo;t simulate forward unless we have the input for the next frame, it&rsquo;s not enough to just take whatever inputs arrive over the network and then run the simulation on inputs as they arrive because the result would be very jittery. Data sent across the network at 60HZ doesn&rsquo;t typically arrive nicely spaced, 1/60th of a second between each packet.</p>
<p>If you want this sort of behavior, you have to implement it yourself.</p>
<h2 id="playout-delay-buffer">Playout Delay Buffer</h2>
<p>Such a device is called a playout delay buffer.</p>
<p>Unfortunately, the subject of playout delay buffers is a patent minefield. I would not advise searching for &ldquo;playout delay buffer&rdquo; or &ldquo;adaptive playout delay&rdquo; while at work. But in short, what you want to do is buffer packets for a short amount of time so they <em>appear</em> to be arriving at a steady rate even though in reality they arrive somewhat jittered.</p>
<p>What you&rsquo;re doing here is similar to what Netflix does when you stream a video. You pause a little bit initially so you have a buffer in case some packets arrive late and then once the delay has elapsed video frames are presented spaced the correct time apart. If your buffer isn&rsquo;t large enough then the video playback will be hitchy. With deterministic lockstep your simulation behaves exactly the same way: showing hitches when the buffer isn&rsquo;t large enough to smooth out the jitter. Of course, the cost of increasing the buffer size is additional latency, so you can&rsquo;t just buffer your way out of all problems. At some point the user says enough! That&rsquo;s too much latency added. No sir, I will <em>not</em> play your game with 1 second of extra delay :)</p>
<p>My playout delay buffer implementation is really simple. You add inputs to it indexed by frame, and when the very first input is received, it stores the current local time on the receiver machine and from that point on delivers packets assuming they should play at that time + 100ms. You&rsquo;ll likely need to something more complex for a real world situation, perhaps something that handles clock drift, and detecting when the simulation should slightly speed up or slow down to maintain a nice amount of buffering safety (being &ldquo;adaptive&rdquo;) while minimizing overall latency, but this is reasonably complicated and probably worth an article in itself.</p>
<p>The goal is that under average conditions the playout delay buffer provides a steady stream of inputs for frame n, n+1, n+2 and so on, nicely spaced 1/60th of a second apart with no drama. In the worst case the time arrives for frame n and the input hasn&rsquo;t arrived yet it returns null and the simulation is forced to wait. If packets get bunched up and delivered late, it&rsquo;s possibly to have multiple inputs ready to dequeue per-frame. In this case I limit to 4 simulated frames per-render frame so the simulation has a chance to catch up, but doesn&rsquo;t simulate for so long that it falls further behind, aka. the &ldquo;spiral of death&rdquo;.</p>
<h2 id="is-tcp-good-enough">Is TCP good enough?</h2>
<p>Using this playout buffer strategy and sending inputs across TCP we ensure that all inputs arrive reliably and in-order. This is convenient, and after all, TCP is designed for exactly this situation: reliable-ordered data.</p>
<p>In fact, It&rsquo;s a common thing out there on the Internet for pundits to say stuff like:</p>
<ul>
<li><p><a href="https://www.reddit.com/r/gamedev/comments/1tvbe0/is_it_just_me_or_is_networking_really_hard/">If you need reliable-ordered, you can&rsquo;t do better than TCP!</a></p></li>
<li><p><a href="https://thoughtstreams.io/glyph/your-game-doesnt-need-udp-yet/">Your game doesn&rsquo;t need UDP (yet)</a></p></li>
</ul>
<p>But I&rsquo;m here to tell you this kind of thinking is <strong>dead wrong</strong>.</p>
<video autoplay preload="auto" loop="true" width="100%" controls="controls">
<source src="/img/deterministic_lockstep_3.mp4" type="video/mp4" />
</video>
<p>Above you can see the simulation networked using deterministic lockstep over TCP at 100ms latency and 1% packet loss. If you look closely on the right side you can see hitches every few seconds. What&rsquo;s happening here is that each time a packet is lost, TCP has to wait RTT*2 while it is resent (actually it can be much worse, but I&rsquo;m being generous&hellip;). The hitches happen because with deterministic lockstep the right simulation can&rsquo;t simulate frame n without input n, so it has to pause to wait for input n to be resent!</p>
<p>That&rsquo;s not all. It gets significantly worse as latency and packet loss increase. Here is the same simulation networked using deterministic lockstep over TCP at 250ms latency and 5% packet loss:</p>
<video autoplay preload="auto" loop="true" width="100%" controls="controls">
<source src="/img/deterministic_lockstep_4.mp4" type="video/mp4" />
</video>
<p>Now I will concede that if you have no packet loss and/or a very small amount of latency then you very well may get acceptable results with TCP. But please be aware that if you use TCP it behaves <em>terribly</em> under bad network conditions.</p>
<h2 id="can-we-do-better-than-tcp">Can we do better than TCP?</h2>
<p>Can we beat TCP at its own game. Reliable-ordered delivery?</p>
<p>The answer is an emphatic <b>YES</b>. But <em>only</em> if we change the rules of the game.</p>
<p>Here&rsquo;s the trick. We need to ensure that all inputs arrive reliably and in order. But if we send inputs in UDP packets, some of those packets will be lost. What if, instead of detecting packet loss after the fact and resending lost packets, we redundantly include <em>all inputs</em> in each UDP packet until we know for sure the other side has received them?</p>
<p>Inputs are very small (6 bits). Let&rsquo;s say we&rsquo;re sending 60 inputs per-second (60fps simulation) and round trip time we know is going the be somewhere in 30-250ms range. Let&rsquo;s say just for fun that it could be up to 2 seconds worst case and at this point we&rsquo;ll time out the connection (screw that guy). This means that on average we only need to include between 2-15 frames of input and worst case we&rsquo;ll need 120 inputs. Worst case is 120*6 = 720 bits. That&rsquo;s only 90 bytes of input! That&rsquo;s totally reasonable.</p>
<p>We can do even better. It&rsquo;s not common for inputs to change every frame. What if when we send our packet instead we start with the sequence number of the most recent input, and the 6 bits of the first (oldest) input, and the number of un-acked inputs. Then as we iterate across these inputs to write them to the packet we can write a single bit (1) if the next input is different to the previous, and (0) if the input is the same. So if the input is different from the previous frame we write 7 bits (rare). If the input is identical we write just one (common). Where inputs change infrequently this is a big win and in the worst case this really isn&rsquo;t that bad. 120 bits of extra data sent. Just 15 bytes overhead worst case.</p>
<p>Of course another packet is required from the right simulation to the left so the left side knows which inputs have been received. Each frame the right simulation reads input packets from the network before adding them to the playout delay buffer and keeps track of the most recent input it has received and sends this back to the left as an &ldquo;ack&rdquo; or acknowledgment for inputs.</p>
<p>When the left side receives this ack it discards any inputs older than the most recent received input. This way we have only a small number of inputs in flight proportional to the round trip time between the two simulations.</p>
<h2 id="flawless-victory">Flawless Victory</h2>
<p>We have beaten TCP by changing the rules of the game.</p>
<p>Instead of &ldquo;implementing 95% of TCP on top of UDP&rdquo; we have implemented something <em>totally different</em> and better suited to our requirements. A protocol that redundantly sends inputs because we know they are small, so we never have to wait for retransmission.</p>
<p>So exactly how much better is this approach than sending inputs over TCP?</p>
<p>Let&rsquo;s take a look&hellip;</p>
<video autoplay preload="auto" loop="true" width="100%" controls="controls">
<source src="/img/deterministic_lockstep_5.mp4" type="video/mp4" />
</video>
<p>The video above shows deterministic lockstep synchronized over UDP using this technique with <strong>2 seconds</strong> of latency and <strong>25% packet loss</strong>. Imagine how awful TCP would look under these conditions.</p>
<p>So in conclusion, even where TCP should have the most advantage, in the only networking model that relies on reliable-ordered data, we can still easily whip its ass with a simple protocol built on top of UDP.</p>

