---
title: 构建游戏网络协议五之可靠的有序消息
date: 2017-03-29 13:13:35
tags:
- GafferOnGames
categories:
- GS
---


# 本篇自我总结

本篇主要讲了数据包的分包和重组问题, 到底数据包多大才好呢?是不是越大越好呢?包太大了怎么办呢?
请看总结, 不明之处再看文中具体讲解.

## 为什么需要做这个可靠UDP协议

网络协议在动作游戏类型（FPS）中的典型特征就是一个持续发送的数据包，在两个方向上以稳定的速度如20或30包每秒发送。这些数据包都包含有不可靠的无序数据例如t时间内的世界状态；所以，当一个数据包丢失，重新发送它并不是特别有用。当重新发送的数据包到达时，时间t已经过去了。

所以这就是我们将要实现可靠性的现状。对于我们90%的数据包，仅丢弃并不再重新发送它会更好。对于10%或更少（误差允许范围内）的情况，我们确实需要可靠性，但这样的数据是非常罕见的，很少被发送而且比不可靠的数据的平均大小要小得多。这个使用案例适用于所有过去十五年来发布的AAA级的FPS游戏。

## 应答系统是实现可靠UDP的最重要的部分

为实现数据包层级的应答，在每个包的前面添加如下的报头：

``` c++
struct Header
{
    uint16_t sequence;
    uint16_t ack;
    uint32_t ack_bits;
};
```

这些报头元素组合起来以创建应答系统：

- sequence 是一个数字，随每个数据包发送而增长（并且在达到65535后回往复）。
- ack 是从另一方接收到的最新的数据包序列号。
- ack_bits 是一个位字段，它编码与ack相关的收到的数据包组合：如果位n已经设置，即 ack– n 数据包被接收了。

ack_bits 不仅是一个节省带宽的巧妙的编码，它同样也增加了信息冗余来抵御包的丢失。每个应答码要被发送32次。如果有一个包丢失了，仍然有其他31个包有着相同的应答码。从统计上来说，应答码还是非常有可能送达的。

但突发的传送数据包的丢失还是有可能发生的，所以重要的是要注意：

- 如果你收到一个数据包n的应答码，那么这个包肯定已经收到了。
- 如果你没有收到应答码，那么这个包就很有可能 没有被收到。但是…它也许会是，仅是应答码没有送达。这种情况是极其罕见的。

以我的经验，没有必要设计完善的应答机制。在一个极少丢应答码的系统上构建一个可靠性系统并不会增加什么大问题。


## 发送方如何追踪数据包是否已经被应答

为实现这个应答系统，我们在发送方还需要一个数据结构来追踪一个数据包是否已经被应答，这样我们就可以忽略冗余的应答（每个包会通过 `ack_bits`多次应答)。我们同样在接收方也还需要一个数据结构来追踪那些已经收到的包，这样我们就可以在数据包的报头填写`ack_bits`的值。

``` c++
const int BufferSize = 1024;
 
uint32_t sequence_buffer[BufferSize];
 
struct PacketData
{
    bool acked;
};
 
PacketData packet_data[BufferSize];
 
PacketData * GetPacketData( uint16_t sequence )
{
    const int index = sequence % BufferSize;
    if ( sequence_buffer[index] == sequence )
        return &packet_data[index];
    else
        return NULL;
}
```
你在这可以看到的窍门是这个滚动的缓冲区是以序列号来作为索引的：

`const int index =sequence % BufferSize;`

当条目被顺序添加，就像一个被发送的队列，对插入所需要做的就是把这个序列缓冲区的值更新为新的序列号并且在该索引处重写这个数据：

``` c++
PacketData & InsertPacketData( uint16_t sequence )
{
    const int index = sequence % BufferSize;
    sequence_buffer[index] = sequence;
    return packet_data[index];
}
```


# 原文

[原文出处](https://gafferongames.com/post/reliable_ordered_messages/)

原文标题 : **Reliable Ordered Messages** (*How to implement reliable-ordered messages on top of UDP*)



-------------------


<h2 id="introduction">Introduction</h2>
<p>Hi, I’m <a href="https://gafferongames.com/about">Glenn Fiedler</a> and welcome to <strong><a href="https://gafferongames.com/categories/building-a-game-network-protocol/">Building a Game Network Protocol</a></strong>.</p>
<p>Many people will tell you that implementing your own reliable message system on top of UDP is foolish. After all, why reimplement TCP?</p>
<p>But why limit ourselves to how TCP works? But there are so many different ways to implement reliable-messages and most of them work <em>nothing</em> like TCP!</p>
<p>So let&rsquo;s get creative and work out how we can implement a reliable message system that&rsquo;s <em>better</em> and <em>more flexible</em> than TCP for real-time games.</p>
<h2 id="different-approaches">Different Approaches</h2>
<p>A common approach to reliability in games is to have two packet types: reliable-ordered and unreliable. You&rsquo;ll see this approach in many network libraries.</p>
<p>The basic idea is that the library resends reliable packets until they are received by the other side. This is the option that usually ends up looking a bit like TCP-lite for the reliable-packets. It&rsquo;s not that bad, but you can do much better.</p>
<p>The way I prefer to think of it is that messages are smaller bitpacked elements that know how to serialize themselves. This makes the most sense when the overhead of length prefixing and padding bitpacked messages up to the next byte is undesirable (eg. lots of small messages included in each packet). Sent messages are placed in a queue and each time a packet is sent some of the messages in the send queue are included in the outgoing packet. This way there are no reliable packets that need to be resent. Reliable messages are simply included in outgoing packets until they are received.</p>
<p>The easiest way to do this is to include all unacked messages in each packet sent. It goes something like this: each message sent has an id that increments each time a message is sent. Each outgoing packet includes the start <em>message id</em> followed by the data for <em>n</em> messages. The receiver continually sends back the most recent received message id to the sender as an ack and only messages newer than the most recent acked message id are included in packets.</p>
<p>This is simple and easy to implement but if a large burst of packet loss occurs while you are sending messages you get a spike in packet size due to unacked messages.</p>
<p>You can avoid this by extending the system to have an upper bound on the number of messages included per-packet <em>n</em>. But now if you have a high packet send rate (like 60 packets per-second) you are sending the same message multiple times until you get an ack for that message.</p>
<p>If your round trip time is 100ms each message will be sent 6 times redundantly before being acked on average. Maybe you really need this amount of redundancy because your messages are extremely time critical, but in most cases, your bandwidth would be better spent on other things.</p>
<p>The approach I prefer combines packet level acks with a prioritization system that picks the n most important messages to include in each packet. This combines time critical delivery and the ability to send only n messages per-packet, while distributing sends across all messages in the send queue.</p>
<h2 id="packet-level-acks">Packet Level Acks</h2>
<p>To implement packet level acks, we add the following packet header:</p>
<pre>struct Header
{
    uint16_t sequence;
    uint16_t ack;
    uint32_t ack_bits;
};
</pre>
<p>These header elements combine to create the ack system: <strong>sequence</strong> is a number that increases with each packet sent, <strong>ack</strong> is the most recent packet sequence number received, and <strong>ack_bits</strong> is a bitfield encoding the set of acked packets.</p>
<p>If bit <strong>n</strong> is set in <strong>ack_bits</strong>, then <strong>ack - n</strong> is acked. Not only is <strong>ack_bits</strong> a smart encoding that saves bandwidth, it also adds <em>redundancy</em> to combat packet loss. Each ack is sent 32 times. If one packet is lost, there&rsquo;s 31 other packets with the same ack. Statistically speaking, acks are very likely to get through.</p>
<p>But bursts of packet loss do happen, so it&rsquo;s important to note that:</p>
<ol>
<li><p>If you receive an ack for packet n then that packet was <strong>definitely received</strong>.</p></li>
<li><p>If you don&rsquo;t receive an ack, the packet was <em>most likely</em> not received. But, it might have been, and the ack just didn&rsquo;t get through. <strong>This is extremely rare</strong>.</p></li>
</ol>
<p>In my experience it&rsquo;s not necessary to send perfect acks. Building a reliability system on top of a system that very rarely drops acks adds no significant problems. But it does create a challenge for testing this system works under all situations because of the edge cases when acks are dropped.</p>
<p>So please if you do implement this system yourself, setup a soak test with terrible network conditions to make sure your ack system is working correctly. You&rsquo;ll find such a soak test in the <a href="http://www.patreon.com/gafferongames">example source code</a> for this article, and the open source network libraries <a href="https://github.com/networkprotocol/reliable.io">reliable.io</a> and <a href="http://www.libyojimbo.com">yojimbo</a> which also implement this technique.</p>
<h2 id="sequence-buffers">Sequence Buffers</h2>
<p>To implement this ack system we need a data structure on the sender side to track whether a packet has been acked so we can ignore redundant acks (each packet is acked multiple times via <strong>ack_bits</strong>. We also need a data structure on the receiver side to keep track of which packets have been received so we can fill in the <strong>ack_bits</strong> value in the packet header.</p>
<p>The data structure should have the following properties:</p>
<ul>
<li>Constant time insertion (inserts may be <em>random</em>, for example out of order packets&hellip;)</li>
<li>Constant time query if an entry exists given a packet sequence number</li>
<li>Constant time access for the data stored for a given packet sequence number</li>
<li>Constant time removal of entries</li>
</ul>
<p>You might be thinking. Oh of course, <em>hash table</em>. But there&rsquo;s a much simpler way:</p>
<pre>const int BufferSize = 1024;

uint32_t sequence_buffer[BufferSize];

struct PacketData
{
    bool acked;
};

PacketData packet_data[BufferSize];

PacketData * GetPacketData( uint16_t sequence )
{
    const int index = sequence % BufferSize;
    if ( sequence_buffer[index] == sequence )
        return &amp;packet_data[index];
    else
        return NULL;
}
</pre>
<p>As you can see the trick here is a rolling buffer indexed by sequence number:</p>
<pre>const int index = sequence % BufferSize;
</pre>
<p>This works because we don&rsquo;t care about being destructive to old entries. As the sequence number increases older entries are naturally overwritten as we insert new ones. The sequence_buffer[index] value is used to test if the entry at that index actually corresponds to the sequence number you&rsquo;re looking for. A sequence buffer value of 0xFFFFFFFF indicates an empty entry and naturally returns NULL for any sequence number query without an extra branch.</p>
<p>When entries are added in order like a send queue, all that needs to be done on insert is to update the sequence buffer value to the new sequence number and overwrite the data at that index:</p>
<pre>PacketData &amp; InsertPacketData( uint16_t sequence )
{
    const int index = sequence % BufferSize;
    sequence_buffer[index] = sequence;
    return packet_data[index];
}
</pre>
<p>Unfortunately, on the receive side packets arrive out of order and some are lost. Under ridiculously high packet loss (99%) I&rsquo;ve seen old sequence buffer entries stick around from before the previous sequence number wrap at 65535 and break my ack logic (leading to false acks and broken reliability where the sender thinks the other side has received something they haven&rsquo;t&hellip;).</p>
<p>The solution to this problem is to walk between the previous highest insert sequence and the new insert sequence (if it is more recent) and clear those entries in the sequence buffer to 0xFFFFFFFF. Now in the common case, insert is <em>very close</em> to constant time, but worst case is linear where n is the number of sequence entries between the previous highest insert sequence and the current insert sequence.</p>
<p>Before we move on I would like to note that you can do much more with this data structure than just acks. For example, you could extend the per-packet data to include time sent:</p>
<pre>struct PacketData
{
    bool acked;
    double send_time;
};
</pre>
<p>With this information you can create your own estimate of round trip time by comparing send time to current time when packets are acked and taking an <a href="https://en.wikipedia.org/wiki/Exponential_smoothing">exponentially smoothed moving average</a>. You can even look at packets in the sent packet sequence buffer older than your RTT estimate (you should have received an ack for them by now&hellip;) to create your own packet loss estimate.</p>
<h2 id="ack-algorithm">Ack Algorithm</h2>
<p>Now that we have the data structures and packet header, here is the algorithm for implementing packet level acks:</p>
<p><strong>On packet send:</strong></p>
<ol>
<li><p>Insert an entry for for the current send packet sequence number in the sent packet sequence buffer with data indicating that it hasn&rsquo;t been acked yet</p></li>
<li><p>Generate <strong>ack</strong> and <strong>ack_bits</strong> from the contents of the local received packet sequence buffer and the most recent received packet sequence number</p></li>
<li><p>Fill the packet header with <strong>sequence</strong>, <strong>ack</strong> and <strong>ack_bits</strong></p></li>
<li><p>Send the packet and increment the send packet sequence number</p></li>
</ol>
<p><strong>On packet receive:</strong></p>
<ol>
<li><p>Read in <strong>sequence</strong> from the packet header</p></li>
<li><p>If <strong>sequence</strong> is more recent than the previous most recent received packet sequence number, update the most recent received packet sequence number</p></li>
<li><p>Insert an entry for this packet in the received packet sequence buffer</p></li>
<li><p>Decode the set of acked packet sequence numbers from <strong>ack</strong> and <strong>ack_bits</strong> in the packet header.</p></li>
<li><p>Iterate across all acked packet sequence numbers and for any packet that is not already acked call <strong>OnPacketAcked</strong>( uint16_t sequence ) and mark that packet as <em>acked</em> in the sent packet sequence buffer.</p></li>
</ol>
<p>Importantly this algorithm is done on both sides so if you have a client and a server then each side of the connection runs the same logic, maintaining its own sequence number for sent packets, tracking most recent received packet sequence # from the other side and a sequence buffer of received packets from which it generates <strong>sequence</strong>, <strong>ack</strong> and <strong>ack_bits</strong> to send to the other side.</p>
<p>And that&rsquo;s really all there is to it. Now you have a callback when a packet is received by the other side: <strong>OnPacketAcked</strong>. The main benefit of this ack system is now that you know which packets were received, you can build <em>any</em> reliability system you want on top. It&rsquo;s not limited to just reliable-ordered messages. For example, you could use it to implement delta encoding on a per-object basis.</p>
<h2 id="message-objects">Message Objects</h2>
<p>Messages are small objects (smaller than packet size, so that many will fit in a typical packet) that know how to serialize themselves. In my system they perform serialization using a <a href="https://gafferongames.com/building-a-game-network-protocol/serialization-strategies">unified serialize function</a>unified serialize function.</p>
<p>The serialize function is templated so you write it once and it handles read, write and <em>measure</em>.</p>
<p>Yes. Measure. One of my favorite tricks is to have a dummy stream class called <strong>MeasureStream</strong> that doesn&rsquo;t do any actual serialization but just measures the number of bits that <em>would</em> be written if you called the serialize function. This is particularly useful for working out which messages are going to fit into your packet, especially when messages themselves can have arbitrarily complex serialize functions.</p>
<pre>struct TestMessage : public Message
{
    uint32_t a,b,c;

    TestMessage()
    {
        a = 0;
        b = 0;
        c = 0;
    }

    template &lt;typename Stream&gt; bool Serialize( Stream &amp; stream )
    { 
        serialize_bits( stream, a, 32 );
        serialize_bits( stream, b, 32 );
        serialize_bits( stream, c, 32 );
        return true;
    }

    virtual SerializeInternal( WriteStream &amp; stream )
    {
        return Serialize( stream );
    }

    virtual SerializeInternal( ReadStream &amp; stream )
    {
        return Serialize( stream );
    }

    virtual SerializeInternal( MeasureStream &amp; stream )
    {
        return Serialize( stream );        
    }
};
</pre>
<p>The trick here is to bridge the unified templated serialize function (so you only have to write it once) to virtual serialize methods by calling into it from virtual functions per-stream type. I usually wrap this boilerplate with a macro, but it&rsquo;s expanded in the code above so you can see what&rsquo;s going on.</p>
<p>Now when you have a base message pointer you can do this and it <em>just works</em>:</p>
<pre>Message * message = CreateSomeMessage();
message-&gt;SerializeInternal( stream );
</pre>
<p>An alternative if you know the full set of messages at compile time is to implement a big switch statement on message type casting to the correct message type before calling into the serialize function for each type. I&rsquo;ve done this in the past on console platform implementations of this message system (eg. PS3 SPUs) but for applications today (2016) the overhead of virtual functions is neglible.</p>
<p>Messages derive from a base class that provides a common interface such as serialization, querying the type of a message and reference counting. Reference counting is necessary because messages are passed around by pointer and stored not only in the message send queue until acked, but also in outgoing packets which are themselves C++ structs.</p>
<p>This is a strategy to avoid copying data by passing both messages and packets around by pointer. Somewhere else (ideally on a separate thread) packets and the messages inside them are serialized to a buffer. Eventually, when no references to a message exist in the message send queue (the message is acked) and no packets including that message remain in the packet send queue, the message is destroyed.</p>
<p>We also need a way to create messages. I do this with a message factory class with a virtual function overriden to create a message by type. It&rsquo;s good if the packet factory also knows the total number of message types, so we can serialize a message type over the network with tight bounds and discard malicious packets with message type values outside of the valid range:</p>
<pre>enum TestMessageTypes
{
    TEST_MESSAGE_A,
    TEST_MESSAGE_B,
    TEST_MESSAGE_C,
    TEST_MESSAGE_NUM_TYPES
};

// message definitions omitted

class TestMessageFactory : public MessageFactory
{ 
public:

    Message * Create( int type )
    {
        switch ( type )
        {
            case TEST_MESSAGE_A: return new TestMessageA();
            case TEST_MESSAGE_B: return new TestMessageB();
            case TEST_MESSAGE_C: return new TestMessageC();
        }
    }

    virtual int GetNumTypes() const
    {
        return TEST_MESSAGE_NUM_TYPES;
    }
};
</pre>
<p>Again, this is boilerplate and is usually wrapped by macros, but underneath this is what&rsquo;s going on.</p>
<h2 id="reliable-ordered-message-algorithm">Reliable Ordered Message Algorithm</h2>
<p>The algorithm for sending reliable-ordered messages is as follows:</p>
<p><strong>On message send:</strong></p>
<ol>
<li><p>Measure how many bits the message serializes to using the measure stream</p></li>
<li><p>Insert the message pointer and the # of bits it serializes to into a sequence buffer indexed by message id. Set the time that message has last been sent to -1</p></li>
<li><p>Increment the send message id</p></li>
</ol>
<p><strong>On packet send:</strong></p>
<ol>
<li><p>Walk across the set of messages in the send message sequence buffer between the oldest unacked message id and the most recent inserted message id from left -&gt; right (increasing message id order).</p></li>
<li><p>Never send a message id that the receiver can&rsquo;t buffer or you&rsquo;ll break message acks (since that message won&rsquo;t be buffered, but the packet containing it will be acked, the sender thinks the message has been received, and will not resend it). This means you must <em>never</em> send a message id equal to or more recent than the oldest unacked message id plus the size of the message receive buffer.</p></li>
<li><p>For any message that hasn&rsquo;t been sent in the last 0.1 seconds <em>and</em> fits in the available space we have left in the packet, add it to the list of messages to send. Messages on the left (older messages) naturally have priority due to the iteration order.</p></li>
<li><p>Include the messages in the outgoing packet and add a reference to each message. Make sure the packet destructor decrements the ref count for each message.</p></li>
<li><p>Store the number of messages in the packet <strong>n</strong> and the array of message ids included in the packet in a sequence buffer indexed by the outgoing packet sequence number so they can be used to map packet level acks to the set of messages included in that packet.</p></li>
<li><p>Add the packet to the packet send queue.</p></li>
</ol>
<p><strong>On packet receive:</strong></p>
<ol>
<li><p>Walk across the set of messages included in the packet and insert them in the receive message sequence buffer indexed by their message id.</p></li>
<li><p>The ack system automatically acks the packet sequence number we just received.</p></li>
</ol>
<p><strong>On packet ack:</strong></p>
<ol>
<li><p>Look up the set of messages ids included in the packet by sequence number.</p></li>
<li><p>Remove those messages from the message send queue if they exist and decrease their ref count.</p></li>
<li><p>Update the last unacked message id by walking forward from the previous unacked message id in the send message sequence buffer until a valid message entry is found, or you reach the current send message id. Whichever comes first.</p></li>
</ol>
<p><strong>On message receive:</strong></p>
<ol>
<li><p>Check the receive message sequence buffer to see if a message exists for the current receive message id.</p></li>
<li><p>If the message exists, remove it from the receive message sequence buffer, increment the receive message id and return a pointer to the message.</p></li>
<li><p>Otherwise, no message is available to receive. Return <strong>NULL</strong>.</p></li>
</ol>
<p>In short, messages keep getting included in packets until a packet containing that message is acked. We use a data structure on the sender side to map packet sequence numbers to the set of message ids to ack. Messages are removed from the send queue when they are acked. On the receive side, messages arriving out of order are stored in a sequence buffer indexed by message id, which lets us receive them in the order they were sent.</p>
<h2 id="the-end-result">The End Result</h2>
<p>This provides the user with an interface that looks something like this on send:</p>
<pre>TestMessage * message = (TestMessage*) factory.Create( TEST_MESSAGE );
if ( message )
{
    message-&gt;a = 1;
    message-&gt;b = 2;
    message-&gt;c = 3;
    connection.SendMessage( message );
}</pre>
<p>And on the receive side:</p>
<pre>while ( true )
{
    Message * message = connection.ReceiveMessage();
    if ( !message )
        break;

    if ( message-&gt;GetType() == TEST_MESSAGE )
    {
        TestMessage * testMessage = (TestMessage*) message;
        // process test message
    }

    factory.Release( message );
}
</pre>
<p>Which is flexible enough to implement whatever you like on top of it.</p>


<h1 id="译文">译文</h1>


[译文出处](http://gad.qq.com/program/translateview/7168700)

<div class="WordSection1"><div><p class="MsoNormal" align="left" style="vertical-align: baseline; border: none; padding: 0cm;"><span style="font-family:微软雅黑;font-size:medium;"><span style="color: rgb(34, 34, 34);">译者：翁僖骏（</span><span style="color: rgb(34, 34, 34);"><a href="http://gad.qq.com/user/index?id=304098"><span><span>∈星际长途←</span></span></a></span><span style="color: rgb(34, 34, 34);">）</span><span style="color: rgb(34, 34, 34);">  </span><span style="color: rgb(34, 34, 34);">审校：侯鹏（</span><span style="color: rgb(34, 34, 34);"><a href="http://gad.qq.com/user/index?id=391222"><span><span>叶落&amp;</span></span><span><span>无痕</span></span></a></span><span style="color: rgb(34, 34, 34);">）</span><span style="color: rgb(34, 34, 34);"> </span></span> </p></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>嗨，我是格伦费德勒，欢迎来到</span><u><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#DD3333'>创建一个游戏网络协议</span></u><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>第五篇文章。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>从<span><a rel='nofollow' href="http://gafferongames.com/building-a-game-network-protocol/sending-large-blocks-of-data/"><span style="color:#DD3333"><span>上一篇文章</span></span></a></span>到现在已经有很长一段时间了，上次我已经率先而且实现了余下的这一系列文章所需的源码并创建了开源库<span><a rel='nofollow' href="https://github.com/networkprotocol/libyojimbo"><span style="color:#DD3333">libyojimbo</span></a></span>，是本系列文章所要描述的网络协议的一个质量有保证的的和经过单元测试的版本。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>如果你想要有一个开源库来为自己在<span>UDP</span>之上实现可靠消息或是为了其他更多，看看<span><a rel='nofollow' href="https://github.com/networkprotocol/libyojimbo"><span style="color:#DD3333">libyojimbo</span></a></span>。但是，如果你像我这样是想理解它具体是怎么工作的并且可能自己去实现它，阅读下去，因为我们将要从头到脚地去建立一个在<span>UDP</span>之上用来发送可靠有序消息的完整的系统！</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><h2 id="说明"><span style='font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>说明</span></h2> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>很多人也许会跟你说，要在<span>UDP</span>之上实现你自己的可靠消息系统是愚蠢的。为什么要撰写你特有的简化版本的<span>TCP</span>？这些人深信，任何可靠性的实现<i><u><span style="border:none windowtext 1.0pt;padding:0cm">不可避免地</span></u></i><span> </span>最终会成为一个（简化的）<span>TCP</span>的重实现。 </span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>但也有很多不同的方法来在<span>UDP</span>之上实现可靠消息，各有不同的优势和劣势。<span>TCP</span>的方法并不是唯一的选择。事实上，我所了解到的大多数可靠有序信息的选择的原理和<span>TCP</span>并不相同。所以让我们为我们的目标发挥创造力并弄懂我们该如何充分利用我们的现状来实现一个比<span>TCP</span><i><u><span style="border:none windowtext 1.0pt;padding:0cm">更好</span></u></i><span> </span>的可靠性系统。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>网络协议在动作游戏类型（<span>FPS</span>）中的典型特征就是一个<u><span style="border:none windowtext 1.0pt;padding:0cm">持续发送的数据包，</span></u>在两个方向上以稳定的速度如<span>20</span>或<span>30</span>包每秒发送。这些数据包都包含有不可靠的无序数据例如<span>t</span>时间内的世界状态；所以，当一个数据包丢失，重新发送它并不是特别有用。当重新发送的数据包到达时，时间<span>t</span>已经过去了。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>所以这就是我们将要实现可靠性的现状。对于我们<span>90%</span>的数据包，仅丢弃并不再重新发送它会更好。对于<span>10%</span>或更少（误差允许范围内）的情况，我们确实需要可靠性，但这样的数据是非常罕见的，很少被发送而且比不可靠的数据的平均大小要小得多。这个使用案例适用于所有过去十五年来发布的<span>AAA</span>级的<span>FPS</span>游戏。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><h2 id="不同的方法"><span style='font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>不同的方法</span></h2> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>可靠性的一个常用的方法是使用两种包类型：可靠有序的和不可靠的。你在众多网络库中都会看到这个方法。它基本的想法是，这个库不断重新发送可靠的数据包直到它的另一方接收到为止。这是一个最终看起来会有一点像<span>TCP</span>方式传输的可靠包的选择。这并没有很糟糕，但你也可以做得更好。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>我更愿意去考虑的方法就是消息其实是更小的位包装元素，它知道如何使它们自己序列化。这就显得非常有意义了，因为按位打包的消息中，用于描述下个字节的前缀或者后缀的字节开销在大部分的情况下是不必需的（例如每个包中包含的许多小的消息）。被发送的消息会被放在一个队列并且每次一个包被发送时，发送队列中的一些消息就会被包含在外发的包中。这样一来，就没有可靠的数据包需要被重新发送了。可靠消息也只会包含在数据包里直到它们被接收。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>要做到这样最简单的方法就是，把所有未应答的消息包含到每个被发送的包中。它是这样的：每个被发送的消息都有一个随每当一个消息被发送时递增的<span>id</span>。每个输出数据包包含起始<b><span style="border:none windowtext 1.0pt;padding:0cm">消息<span>id</span></span></b><span> </span>，紧跟着的是<b><span style="border:none windowtext 1.0pt;padding:0cm">n</span></b><span> </span>个消息的数据。接收方不断发回最新收到消息的<span>id</span>给发送方作为一个应答信号，并且消息要当且仅当比最新的应答消息<span>id</span>要更新，才会被包含在数据包中。 </span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这很简单也易于实现，但当你正在发送消息时如果突发一个很大的包丢失情况，你会遇到一个数据包大小的峰值，因为有很多未应答的消息。。正如在<span><a rel='nofollow' href="http://gafferongames.com/building-a-game-network-protocol/packet-fragmentation-and-reassembly/"><span style="color:#DD3333"><span>数据包分割</span></span><span style="color:#DD3333"><span>和重组</span></span></a></span>中讨论的需要按照<span>MTU</span>分割包的方式来发送大的数据包会增加丢包的情况。在高丢包率下你最不想做的就是增大包的规格并引起更多的包的丢失。这是一个潜在的无底洞。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>你可以通过扩展系统来给每个包的消息数量<span>n</span>设置一个上限，来避免这种情况。但现在如果你有一个高数据包发送率（如每秒<span>60</span>包）你就要多次发送同样的消息直到你得到该消息的应答信号。如果的往返时间是<span>100ms</span>，每条消息在被应答之前将要平均被多余发送六次。也许你真的需要这些多余的发送数量因为你的消息是对时间极其敏感的，但在大多数情况下，你应该给队列里的其他消息分配合理的带宽。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>我比较喜欢的方法是用一个优先次序系统整合每包的应答信号，这个系统检出<span>n</span>条最重要的消息并包含在每个包中。在散布的消息穿过所有在发送队列中的消息发送时，这样就把对时间敏感的递送与每包仅发送<span>n</span>条消息的能力联合起来了。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><h2 id="数据包层级应答"><span style='font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>数据包层级应答</span></h2> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="line-height: 150%; font-size: 12pt; font-family: 微软雅黑, sans-serif; color: rgb(34, 34, 34);">让我们行动起来实现它。</span> <span style="line-height: 150%; color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;">这种可靠性系统的基础是每个包的应答。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>但为什么应答是在数据包层级而不是在消息层级呢？简要截说原因就是包的数量会远远少于消息的数量。假设每个包中有<span>32</span>或<span>64</span>条消息，显然让一个包含<span>32</span>或<span>64</span>条消息的包来应答会比让每个消息都分别应答要高效得多。</span> </p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这样同样也增加了灵活性，因为你可以在数据包层级应答上构建其他可靠性系统，不仅仅是为了可靠有序的消息。例如，使用了数据包层级应答，你就知道哪一个时间先决的不可靠状态更新已结束，所以你可以轻易地构建一个系统，在一旦一个数据包所包含的最后一个状态更新已经应答时，停止发送不再改变的对象状态。</span> </p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>为实现数据包层级的应答，在每个包的前面添加如下的报头：</span></p><div><div id="highlighter_102525" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">Header</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t sequence;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t ack;</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint32_t ack_bits;</code></div><div class="line number6 index5 alt1"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><br  /></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这些报头元素组合起来以创建应答系统：</span> </p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;     border:none windowtext 1.0pt;padding:0cm'>sequence</span></b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'> </span><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>是一个数字，随每个数据包发送而增长（并且在达到<span>65535</span>后回往复）。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;     border:none windowtext 1.0pt;padding:0cm'>ack</span></b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'> </span><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>是从另一方接收到的最新的数据包序列号。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;     border:none windowtext 1.0pt;padding:0cm'>ack_bits</span></b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'> </span><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>是一个位字段，它编码与<b><span style="border:none windowtext 1.0pt;padding:0cm">ack</span></b>相关的收到的数据包组合：如果位<b><span style="border:none windowtext 1.0pt;padding:0cm">n</span></b>已经设置，即<span> <b><span style="border:none windowtext 1.0pt;padding:     0cm">ack–</span></b> <b><span style="border:none windowtext 1.0pt;     padding:0cm">n</span></b> </span>数据包被接收了。</span> </li></ul><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>ack_bits</span></b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'> </span><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>不仅是一个节省带宽的巧妙的编码，它同样也增加了<u><span style="border:none windowtext 1.0pt;padding:0cm">信息冗余</span></u>来抵御包的丢失。每个应答码要被发送<span>32</span>次。如果有一个包丢失了，仍然有其他<span>31</span>个包有着相同的应答码。从统计上来说，应答码还是非常有可能送达的。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>但突发的传送数据包的丢失还是有可能发生的，所以重要的是要注意：</span> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>如果你收到一个数据包<span>n</span>的应答码，那么这个包<u><span style="border:none windowtext 1.0pt;     padding:0cm">肯定已经收到</span></u>了。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>如果你没有收到应答码，那么这个包就<i><span style="border:none windowtext 1.0pt;padding:0cm">很有可能</span></i><span> </span>没有被收到。但是<span>…</span>它也许会是，仅是应答码没有送达。<u><span style="border:none windowtext 1.0pt;padding:0cm">这种情况是极其罕见的。</span></u> </span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>以我的经验，没有必要设计完善的应答机制。在一个极少丢应答码的系统上构建一个可靠性系统并不会增加什么大问题。但对于在所有情况下来测试这个系统的工作将会成为很大的挑战，因为还要考虑应答码丢失的边界情况。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>所以如果你自己实现这个系统的话，请设置一个浸泡测试来覆盖糟糕的网络情况，用来确保你的应答系统是在正确的工作，相关地，你的消息系统的执行实际上是在这些网络情况下<i><u>可靠地而且有序的</u></i>交付可靠有序消息。以我之见（并且我已经写了许多这样的系统的变式至少有十次了），这是确保正确行为的一个必要步骤。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>你在这篇文章的示例源代码中会找到这样一个浸泡测试，它对<span><a rel='nofollow' href="https://www.patreon.com/gafferongames"><span style="color:#DD3333">patreon</span><span style="color:#DD3333"><span>支持</span></span></a></span>是有效的，并且也在开源网络库<span><a rel='nofollow' href="http://www.libyojimbo.com/"><span style="color:#DD3333">libyojimbo</span></a></span>中。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><h2 id="序列缓冲区"><span style='font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>序列缓冲区</span></h2> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>为实现这个应答系统，我们在发送方还需要一个数据结构来追踪一个数据包是否已经被应答，这样我们就可以忽略冗余的应答（每个包会通过<span> <b><span style="border:none windowtext 1.0pt;padding:0cm">ack_bits</span></b></span>多次应答）。我们同样在接收方也还需要一个数据结构来追踪那些已经收到的包，这样我们就可以在数据包的报头填写<b><span style="border:none windowtext 1.0pt;padding:0cm">ack_bits</span></b>的值。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这个数据结构应该具有以下属性：</span> </p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>常量时间内插入（插入可能会是<i><u><span style="border:none windowtext 1.0pt;padding:0cm">随机</span></u></i>的，例如乱序数据包<span>…</span>）</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>给定的数据包的序列号在常量时间内查询一个条目是否存在</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>对给定的数据包序列号，在常量时间内访问数据存储</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>常量时间内删除条目</span> </li></ul><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>你可能会想。哦，当然，<i><u><span style="border:none windowtext 1.0pt;padding:0cm">哈希表</span></u></i>。但还有一个更简单的方法：</span></p><div><div id="highlighter_389542" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">BufferSize = 1024;</code></div><div class="line number2 index1 alt1"> </div><div class="line number3 index2 alt2"><code class="cpp plain">uint32_t sequence_buffer[BufferSize];</code></div><div class="line number4 index3 alt1"> </div><div class="line number5 index4 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">PacketData</code></div><div class="line number6 index5 alt1"><code class="cpp plain">{</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">acked;</code></div><div class="line number8 index7 alt1"><code class="cpp plain">};</code></div><div class="line number9 index8 alt2"> </div><div class="line number10 index9 alt1"><code class="cpp plain">PacketData packet_data[BufferSize];</code></div><div class="line number11 index10 alt2"> </div><div class="line number12 index11 alt1"><code class="cpp plain">`PacketData * GetPacketData( uint16_t sequence )`</code></div><div class="line number13 index12 alt2"><code class="cpp plain">{</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">index = sequence % BufferSize;</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( sequence_buffer[index] == sequence )</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp plain">&amp;packet_data[index];</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">else</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp plain">NULL;</code></div><div class="line number19 index18 alt2"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br  /></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>你在这可以看到的窍门是这个滚动的缓冲区是以序列号来作为索引的：</span> </p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-family:&quot;Courier New&quot;;color:#222222'>const int index =sequence % BufferSize;</span> </p></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这是可行的，因为我们并不在意旧条目破坏。随着序列号的递增，旧的条目也自然而然地随着我们插入了新条目而被重写。<span>sequence_buffer[index]</span>的值是用来测试该索引的条目是否实际上与你所搜寻的序列号相符。一个缓冲序列的值是<span>0xFFFFFFFF </span>就表示一个空的条目并自然地对任何序列号查询返回<span>NULL</span>，没有任何其他（代码）分支。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>当条目被顺序添加，就像一个被发送的队列，对插入所需要做的就是把这个序列缓冲区的值更新为新的序列号并且在该索引处重写这个数据：</span></p><div><div id="highlighter_839387" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">PacketData &amp; InsertPacketData( uint16_t sequence )</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">index = sequence % BufferSize;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp plain">sequence_buffer[index] = sequence;</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">return</code> <code class="cpp plain">packet_data[index];</code></div><div class="line number6 index5 alt1"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br  /></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>但在接收端数据包以乱序到达并且有一部分丢失。在高得离谱的丢包率下（<span>99%</span>），我就会看到旧的序列缓冲区条目还存在，但是新条目的序列号已经超过了<span>65535</span>并且循环到达了旧条目之前，并且打破了我的应答逻辑（导致错误应答并打破了可靠性，这时发送方会真的认为对方已经接收到了一些东西但其实并不是<span>…</span>）</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>解决这个问题的办法是遍历上一个最高的插入序列与最新收到的插入序列之间的条目（如果它是更加新的话）并在缓冲区清除这些条目即都置为<span>0xFFFFFFFF</span>。现在，在一般情况下，插入操作是<i><u><span style="border:none windowtext 1.0pt;padding:0cm">非常接近</span></u></i><span> </span>时间常量的，但最糟的情况是，在先前最高的序列号和当前插入的序列号之间线性遍历的次数<span>n</span>等于缓冲区的长度。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>在我们继续之前，我想指出，你可以用这个数据结构做更多事情而不仅是对于应答码。例如，你可以加入发送时间，来扩展每个包的数据：</span></p><div><div id="highlighter_615471" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">PacketData</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">acked;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">double</code> <code class="cpp plain">send_time;</code></div><div class="line number5 index4 alt2"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br  /></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>有了这些信息你可以对往返时间通过做指数级的平滑取平均数做修正，最终得到合理的预期往返时间。你甚至可以看到在发送数据包的序列缓存区的数据包会比你<span>RTT</span>预计的（你现在应该已经收到了它们的应答码<span>…</span>）要旧，通过这个往返时间对还没有应答的包做判断，来决定创建你的数据包丢失预计。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><h2 id="应答算法"><span style='font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>应答算法</span></h2> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>现在我们来把注意力集中在数据包层级应答的实际算法上。</span><span style="color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;">该算法如下：</span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>在数据包发送端：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>在数据包发送缓冲区插入一个为当前发送的数据包序列号的条目，并且带着表示它还没有被应答的字段</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>从本地接收到的数据包序列缓存和最新接收到的数据包序列号中生成<span> <b><span style="border:none windowtext 1.0pt;padding:     0cm">ack</span></b> </span>和<b><span style="border:none windowtext 1.0pt;     padding:0cm">ack_bits</span></b><span> </span></span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>填写数据包报头的<b><span style="border:none windowtext 1.0pt;padding:0cm">sequence, ack</span></b><span> </span>和<span> <b><span style="border:     none windowtext 1.0pt;padding:0cm">ack_bits</span></b> </span>值</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>发送数据包并递增发送数据包的序列号</span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>在数据包接收端：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>从数据包报头读取<span> <b><span style="border:none windowtext 1.0pt;padding:     0cm">sequence</span></b> </span></span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>如果<span> <b><span style="border:none windowtext 1.0pt;padding:     0cm">sequence</span></b> </span>比之前的最新收到的数据包序列号要新，就更新最新的接收到的数据包序列号</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>在接收数据包序列缓冲区中为这个数据包插入一个条目</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>从数据包报头中的<b><span style="border:none windowtext 1.0pt;padding:0cm">ack</span></b>和<b><span style="border:none windowtext 1.0pt;padding:0cm">ack_bits</span></b>解码应答的数据包序列号组合</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>迭代应答的数据包序列号以及任何还没有被应答的数据包调用<span> <b><span style="border:none windowtext 1.0pt;padding:     0cm">OnPacketAcked</span></b>( uint16_t sequence ) </span>在数据包发送缓冲区把这个数据包设置为<span>‘</span>已应答的<span>’</span>。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'><br  /></span></li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>重要的一点是这个算法是在两端都可以执行的，所以如果你有一个客户端和一个服务端，然后每一方的连接运行着同样的逻辑，维护自己的序列号发送的数据包，跟踪最新从另一方收到的数据包序列<span>#</span>还有从一个序列缓冲区里接收到的数据包中生成<b><span style="border:none windowtext 1.0pt;padding:0cm">sequence, ack</span></b><span> </span>和<b><span style="border:none windowtext 1.0pt;padding:0cm">ack_bits</span></b><span> </span>来发送到另一方。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>并且这真的就是和它有关的全部了。现在当一个数据包被另一方接收到时，你有一个回调：<b><span style="border:none windowtext 1.0pt;padding:0cm">OnPacketAcked</span></b><span> </span>。这个可靠性系统的关键就在于你得知道哪个数据包被接收，你可以在你想的媒介之上创建<i><u><span style="border:none windowtext 1.0pt;padding:0cm">任何</span></u></i><span> </span>可靠性系统。它不仅限于可靠有序的消息。例如，你可以用它确认哪个不可靠的状态更新已经完成了，用以实现基于每个物体的增量编码。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><h2 id="消息对象"><span style='font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>消息对象</span></h2> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>消息是小型的对象（比数据包大小要小，所以很多消息装配在一个典型的数据包中）并且知道如何将它们自己序列化。在我的系统里，它们使用一个</span><u><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#DD3333'>统一的序列化函数</span></u><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>来执行序列化。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这个序列化的函数是模板化的，所以你只要写它一次它就会处理读、写以及<i><u><span style="border:none windowtext 1.0pt;padding:0cm">测量</span></u></i> 。<i><span style="border:none windowtext 1.0pt;padding:0cm"> </span></i></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>是的。测量。我喜欢的一个技巧就是有一个虚拟流类叫做<b><span style="border:none windowtext 1.0pt;padding:0cm">MeasureStream</span></b>，如果你调用了序列化函数，它不参与任何的序列化，而只是测量<i><u><span style="border:none windowtext 1.0pt;padding:0cm">可能</span></u></i>被写入的比特数。这对于解决哪个消息要装载到你的数据包里，特别是当消息可以有任意复杂的序列化函数的情况时是特别有用的。</span></p><div><div id="highlighter_699334" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div><div class="line number32 index31 alt1">32</div><div class="line number33 index32 alt2">33</div><div class="line number34 index33 alt1">34</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">TestMessage : </code><code class="cpp keyword bold">public</code> <code class="cpp plain">Message</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint32_t a,b,c;</code></div><div class="line number4 index3 alt1"> </div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp plain">TestMessage()</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">        </code><code class="cpp plain">a = 0;</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">        </code><code class="cpp plain">b = 0;</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">        </code><code class="cpp plain">c = 0;</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number11 index10 alt2"> </div><div class="line number12 index11 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">template</code> <code class="cpp plain">&lt;</code><code class="cpp keyword bold">typename</code> <code class="cpp plain">stream</code><code class="cpp string"></code><code class="cpp plain">&gt; </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">Serialize( Stream &amp; stream )</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">    </code><code class="cpp plain">{ </code></div><div class="line number14 index13 alt1"><code class="cpp spaces">        </code><code class="cpp plain">serialize_bits( stream, a, 32 );</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">        </code><code class="cpp plain">serialize_bits( stream, b, 32 );</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">        </code><code class="cpp plain">serialize_bits( stream, c, 32 );</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number19 index18 alt2"> </div><div class="line number20 index19 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">virtual</code> <code class="cpp plain">SerializeInternal( WriteStream &amp; stream )</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp plain">Serialize( stream );</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number24 index23 alt1"> </div><div class="line number25 index24 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">virtual</code> <code class="cpp plain">SerializeInternal( ReadStream &amp; stream )</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number27 index26 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp plain">Serialize( stream );</code></div><div class="line number28 index27 alt1"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number29 index28 alt2"> </div><div class="line number30 index29 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">virtual</code> <code class="cpp plain">SerializeInternal( MeasureStream &amp; stream )</code></div><div class="line number31 index30 alt2"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number32 index31 alt1"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp plain">Serialize( stream );        </code></div><div class="line number33 index32 alt2"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number34 index33 alt1"><code class="cpp plain">};</code><code class="cpp keyword bold"></code><code class="cpp plain"></code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br  /></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这里的技巧是桥接统一模板的序列化函数（所以你只需要写一次）与虚拟序列化方法，这通过从虚函数每个流类型中调入它。我通常用一个宏来打包这个引用，但它在上文的代码中这个宏已经被展开，所以你可以看到发生了什么。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>现在，假设你有一个基于消息的指针可以让你做到这样并且它只是通过重载来工作：</span></p><div><div id="highlighter_300994" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">Message * message = CreateSomeMessage();</code></div><div class="line number2 index1 alt1"><code class="cpp plain">message-&gt;SerializeInternal( stream );</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>另外一个就是如果你在编译时间知道了消息的完整组合，就可以为每个类型在被调入序列化函数之前实现一个关于消息类型转换为确切消息类型的大的<span>switch</span>语句。我在过去已经在控制台平台实现的这个消息系统这么做了（如<span>PS3 SPUs</span>），但对于现在（<span>2016</span>）的应用程序，虚函数的总开销是忽略不计的。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>消息从一个基类派生，这个基类提供一个通用的接口例如序列化、消息的查询类型还有引用计数。引用计数是必要的，因为消息是通过指针传递的并且在应答之前不只是存储在消息发送队列，而且也存储在外发的数据包中，包本身是<span>C++</span>结构体。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这是一个策略，就是避免通过指针传递消息和数据包来复制数据。别的一些场景（理想的情况是在一个单独的线程）它们里面的数据包和消息会序列化到一个缓冲区。最终，当不再有对存在消息发送队列的消息的引用时（消息已经被应答）并且没有数据包包含保留在数据包发送队列里的消息，消息即是被销毁的。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>我们也需要一种方式来创建消息。我用一个消息的工厂类来做这件事情，它有一个被复写的虚函数来根据类型创建一个消息。如果这个数据包工厂还知道消息类型的总数量就好了，那样我们就可以在网络上序列化一个消息类型，因为有严格的界限和在有效范围之外的消息类型值的包的恶意丢弃：</span></p><div><div id="highlighter_935705" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">enum</code> <code class="cpp plain">TestMessageTypes</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp plain">TEST_MESSAGE_A,</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp plain">TEST_MESSAGE_B,</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp plain">TEST_MESSAGE_C,</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">    </code><code class="cpp plain">TEST_MESSAGE_NUM_TYPES</code></div><div class="line number7 index6 alt2"><code class="cpp plain">};</code></div><div class="line number8 index7 alt1"> </div><div class="line number9 index8 alt2"><code class="cpp comments">// message definitions omitted</code></div><div class="line number10 index9 alt1"> </div><div class="line number11 index10 alt2"><code class="cpp keyword bold">class</code> <code class="cpp plain">TestMessageFactory : </code><code class="cpp keyword bold">public</code> <code class="cpp plain">MessageFactory</code></div><div class="line number12 index11 alt1"><code class="cpp plain">{ </code></div><div class="line number13 index12 alt2"><code class="cpp keyword bold">public</code><code class="cpp plain">:</code></div><div class="line number14 index13 alt1"> </div><div class="line number15 index14 alt2"><code class="cpp spaces">    </code><code class="cpp plain">Message * Create( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">type )</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">switch</code> <code class="cpp plain">( type )</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">        </code><code class="cpp plain">{</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">            </code><code class="cpp keyword bold">case</code> <code class="cpp plain">TEST_MESSAGE_A: </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">new</code> <code class="cpp plain">TestMessageA();</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">            </code><code class="cpp keyword bold">case</code> <code class="cpp plain">TEST_MESSAGE_B: </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">new</code> <code class="cpp plain">TestMessageB();</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">            </code><code class="cpp keyword bold">case</code> <code class="cpp plain">TEST_MESSAGE_C: </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">new</code> <code class="cpp plain">TestMessageC();</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">        </code><code class="cpp plain">}</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number24 index23 alt1"> </div><div class="line number25 index24 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">virtual</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">GetNumTypes() </code><code class="cpp keyword bold">const</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number27 index26 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp plain">TEST_MESSAGE_NUM_TYPES;</code></div><div class="line number28 index27 alt1"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number29 index28 alt2"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br  /></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>再次重申，这是一个引用并且通常是被包裹在宏里面的，但下面要说明的就是它具体是怎么回事了。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><h2 id="可靠的有序消息算法"><span style='font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>可靠的有序消息算法</span></h2> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>现在让我们来着手于如何在应答系统中实现可靠有序消息的细节。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>发送可靠有序消息的算法如下：</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>对于消息发送：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>使用测量流测量消息序列化后的大小</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>插入消息指针和它序列化的位数到一个序列缓冲区，它以消息<span>id</span>为索引。设置消息最后被发送的时间为<span>-1</span></span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>递增发送的消息的<span>id</span></span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>对于数据包发送：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>从左<span>-&gt;</span>右（递增的消息<span>id</span>顺序）遍历在最早的未应答消息<span>id</span>和最新插入的消息<span>id</span>之间的发送消息序列缓冲区的这组消息。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;     padding:0cm'>超级重要的：</span></b><span style='font-size:12.0pt;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'> </span><span style='font-size:12.0pt;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>不要发送一个接收方不能缓冲的消息<span>id</span>，不然你会破坏消息的应答（由于这个消息不能被缓冲，但包含它的数据包会被应答，发送方就会认为这个消息已经被接收了，就不再重新发送它了）。这意味着你必须不能发送一个消息<span>id</span>等于或比最早的未应答消息的<span>id</span>加上消息接收缓冲区大小要新。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>对于那些在最后<span>0.1</span>秒没有被发送的消息<u><span style="border:none windowtext 1.0pt;     padding:0cm">并且</span></u>适合我们留在数据包的有效空间，就把它追加到消息列表去发送。根据迭代顺序得到优先级。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>包括在外发数据包中的消息，并且要为每个消息添加一个引用。确保每个数据包的析构函数中减了引用计数。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>在数据包<b><span style="border:none windowtext 1.0pt;padding:0cm">n</span></b>存储消息的数量并且消息的标识数组包含在一个序列缓冲区的数据包中，以外发数据包的序列号为索引。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>把数据包添加到数据包发送队列。</span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>对于数据包接收：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>遍历包含在数据包中的消息组合并且把它们插入到消息接收队列缓冲区，以它们的消息<span>id</span>为索引。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>前面的应答系统自动地应答我们刚刚收到的数据包序列号。</span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>对于数据包应答：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>用序列号查找包含在数据包中消息组合的标识部分。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>从消息发送队列中移除那些已经存在的消息，并减少它们的引用计数。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>通过从发送消息队列缓冲区中之前未应答消息的<span>id</span>的转寄来更新最后一个未应答的消息的<span>id</span>，直到发现一个有效的消息条目，或者你会到达当前发送消息的<span>id</span>。以先到者为准。 </span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>对于消息接收：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>检查接受消息缓冲区确保当前收到消息的<span>id</span>对应的消息是否存在。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>如果消息存在，将它从消息队列缓冲区中移除，递增接收消息的<span>id</span>并给这个消息返回一个指针。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>如果否，就是没有有效的消息可接收。返回<b><span style="border:none windowtext 1.0pt;padding:0cm">NULL</span></b>。</span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>总之，消息要保持被包含在数据包中直到这个数据包包含的消息得到应答。我们在发送者方使用一个数据结构来给消息标识的组合映射数据包序列号以便应答。当消息被应答时，要从发送队列中移除。对于接收方，以乱序到达的消息会被存储在一个序列缓冲区，并以消息<span>id</span>为索引，这个<span>id</span>会让我们以它们被发送的顺序接收它们。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><br  /></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><h2 id="最终的结果"><span style='font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>最终的结果</span></h2> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>在发送方，这为用户提供了一个像这样的接口：</span></p><div><div id="highlighter_731637" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">TestMessage * message = (TestMessage*) factory.Create( TEST_MESSAGE );</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">if</code> <code class="cpp plain">( message )</code></div><div class="line number3 index2 alt2"><code class="cpp plain">{</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp plain">message-&gt;a = 1;</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp plain">message-&gt;b = 2;</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">    </code><code class="cpp plain">message-&gt;c = 3;</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp plain">connection.SendMessage( message );</code></div><div class="line number8 index7 alt1"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br  /></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>还有在接收方：</span></p><div><div id="highlighter_315020" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">while</code> <code class="cpp plain">( </code><code class="cpp keyword bold">true</code> <code class="cpp plain">)</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp plain">Message * message = connection.ReceiveMessage();</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !message )</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">break</code><code class="cpp plain">;</code></div><div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( message-&gt;GetType() == TEST_MESSAGE )</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">        </code><code class="cpp plain">TestMessage * testMessage = (TestMessage*) message;</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">        </code><code class="cpp comments">// process test message</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number12 index11 alt1"> </div><div class="line number13 index12 alt2"><code class="cpp spaces">    </code><code class="cpp plain">factory.Release( message );</code></div><div class="line number14 index13 alt1"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br  /></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>正如你所看到的，它已经是简单得不能再简单了。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>如果这几个接口有引起你的兴趣，请看看我的新开源库<span> <a rel='nofollow' href="https://github.com/networkprotocol/libyojimbo"><span style="color:#DD3333">libyojimbo</span></a></span>。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>我希望你到现在为止对这个系列的文章是享受的<span><a rel='nofollow' href="http://www.patreon.com/gafferongames"><span style="color:#DD3333"><span>请在 patreon</span></span><span style="color:#DD3333"><span>上支持我的写作</span></span></a></span>，并且我将更快写新的文章，再者你会在加州大学伯克利分校软件的开源许可证下获得这篇文章的示例源代码。<b><u><span style="border:none windowtext 1.0pt;padding:0cm">谢谢你的支持！</span></u></b></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222'> </span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style='font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>即将到来：</span></b><b><span style='font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'><a rel='nofollow' href="http://gafferongames.com/building-a-game-network-protocol/client-server-connection/"><span style="color:#DD3333"><span>客户端与服务器的连接</span></span></a></span></b> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>在<span>“</span>创建一个游戏网络协议<span>”</span>的下一篇文章会展示你如何在<span>UDP</span>之上创建你自己的客户端<span>/</span>服务器连接层，它会实现挑战<span>/</span>响应，会在服务器上分配客户端插槽，当服务器爆满或检测超时就拒绝客户端的连接。</span> </p><p class="MsoNormal"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'> </span> </p><p class="MsoNormal"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'> </span> </p><p class="MsoNormal"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>【版权声明】</span> </p><p class="MsoNormal"><span style='font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>原文作者未做权利声明，视为共享知识产权进入公共领域，自动获得授权；</span> </p><p class="MsoNormal"><span> </span> </p></div>                    </div>
                </div>
