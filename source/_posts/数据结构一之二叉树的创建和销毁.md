---
title: 数据结构一之二叉树的创建和销毁
date: 2014-09-22 19:11:22
tags:
- 二叉树
- c++
categories:
- c++
---


接着上一篇， 上一篇主要说了各种排序算法， 但对几个常用的数据结构还未提及，所以这一篇主要讲二叉树, 二叉树已经包括很多链表的知识了。所有代码都是测试过的, 可以直接撸.

# **二叉树**
这里不举太多数字方面的东西， 我们直接看图， 直观感性的认识满二叉树和完全二叉树：
![这里写图片描述](http://img.blog.csdn.net/20170805013035460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbm9zaXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

**有一点性质需要牢记：具有n个结点的完全二叉树的最大高度为log2n+1**

## 二叉树的二叉链式存储

二叉树的二叉链式存储方案的代码表示：

``` c++
typedef struct BinaryTreeNode
{
	void *data;
	BinaryTreeNode *LeftNode;
	BinaryTreeNode *RightNode;
}BTN, *BTNP;
```
![这里写图片描述](http://img.blog.csdn.net/20170805023144001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbm9zaXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

<!-- more -->

## 二叉树的创建

下面代码写法都是基于二叉树的先序遍历来创建二叉树的.
基于中序或者后序的写法都类似.

``` c++

void CreateBinaryTree1(BTNP &btnp)
{
	char inputData = 0;
	cin >> inputData;

	if (inputData == '.')
	{
		btnp = NULL;
		return;
	}

	btnp = new BTN;
	if (!btnp)
	{
		cout << "new error" << endl;
		return;
	}

	char *tempChar = new char;
	*tempChar = inputData;

	// 注意这里不能写成 btnp->data = &inputData; 因为inputData是分配在栈上的
	btnp->data = tempChar;  

	CreateBinaryTree1(btnp->LeftNode);
	CreateBinaryTree1(btnp->RightNode);
}

void CreateBinaryTree2(BTNP *btnp)
{
	char inputData = 0;
	scanf(" %c", &inputData); // 注意这里的%前有个空格

	if (inputData == '.')
	{
		*btnp = NULL;
		return;
	}

	*btnp = (BTNP)malloc(sizeof(BTN));
	if (!*btnp)
	{
		cout << "malloc error" << endl;
		return;
	}

	char *tempChar = new char;
	*tempChar = inputData;
	
	// 注意这里不能写成 (*btnp)->data = &inputData;
	(*btnp)->data = tempChar; 

	CreateBinaryTree2( &( (*btnp)->LeftNode) );
	CreateBinaryTree2( &( (*btnp)->RightNode) );
}

void DeleteBinaryTree(BTNP &btnp)
{
	if (btnp)
	{
		delete btnp->data;
		btnp->data = NULL;

		DeleteBinaryTree(btnp->LeftNode);
		btnp->LeftNode = NULL;

		DeleteBinaryTree(btnp->RightNode);
		btnp->RightNode = NULL;

		delete btnp;
		btnp = NULL;
	}
}
```

