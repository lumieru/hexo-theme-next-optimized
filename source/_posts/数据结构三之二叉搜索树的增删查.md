---
title: 数据结构三之二叉搜索树的增删查
date: 2014-09-24 19:17:32
tags:
- 数据结构
- c++
categories:
- c++
---



有了二叉树的基础, 我们继续学习二叉搜索树.

# 二叉搜索树的定义

**二叉查找树(Binary Search Tree), 又名"二叉搜索树"或"二叉排序树":**
设 x 是二叉搜索树中的一个结点. 如果 y 是 x 左子树的一个结点, 那么 y.key <= x.key. 如果 y 是 x 右子树中的一个结点, 那么 y.key >= x.key.

如下图中, (a)和(b)都是二叉搜索树.

![这里写图片描述](http://img.blog.csdn.net/20170806185002946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbm9zaXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

不过, 因为具有n个结点的完全二叉树的最大高度为log2n+1, 而二叉搜索树的查询/插入的时间复杂度都是O(h), h为树的高度,所以复杂度可以看作O(logn), h越大, 复杂度越高, 所以很明显上图中的(a)树比(b)树要高效.


<!-- more -->

**注 : **

二叉树的二叉链式存储方案的代码表示为
``` c++
typedef struct BinaryTreeNode
{
	void *data;
	BinaryTreeNode *LeftNode;
	BinaryTreeNode *RightNode;
}BTN, *BTNP;
```

# 二叉搜索树的查询
``` c++

BTNP SearchBinarySearchTree(BTNP btnp, char key)
{
	while (btnp)
	{
		if (*(char *)btnp->data > key)
		{
			btnp = btnp->LeftNode;
		}
		else if (*(char *)btnp->data < key)
		{
			btnp = btnp->RightNode;
		}
		else
		{
			cout << "found!!" << endl;
			return btnp;
		}
	}

	cout << "not found!!" << endl;
	return NULL;
}

```

# 二叉搜索树的插入

{% asset_img BinarySearchTreeInsert1.png %}


``` c++

void InsertBinarySearchTree(BTNP &btnp, char key)
{
	BTNP keyBTNP = new BTN;

	char * tempData = new char;
	*tempData = key;
	keyBTNP->data = tempData;

	keyBTNP->LeftNode = NULL;
	keyBTNP->RightNode = NULL;

	if (!btnp)
	{
		btnp = keyBTNP;
		return;
	}

	BTNP tempBTNP = btnp, savedBTNP = NULL;
	bool isLeft = true;
	while (tempBTNP)
	{
		savedBTNP = tempBTNP;
		if (*(char *)tempBTNP->data > key)
		{
			tempBTNP = tempBTNP->LeftNode;
			isLeft = true;
		}
		else
		{
			tempBTNP = tempBTNP->RightNode;
			isLeft = false;
		}
	}

	if (isLeft)
	{
		savedBTNP->LeftNode = keyBTNP;
	}
	else
	{
		savedBTNP->RightNode = keyBTNP;
	}
}

```

# 二叉搜索树之删除某个结点

{% asset_img BinarySearchTreeDelete1.png %}
{% asset_img BinarySearchTreeDelete2.png %}

``` c++

void DeleteBinaraySearchTree(BTNP &btnp, char key)
{
	// 第一步 : 查找是否有这个key
	BTNP parentBTNP = NULL;
	bool isLeft = true;

	BTNP tempBNTP = btnp;

	while (tempBNTP)
	{
		if (*(char*)tempBNTP->data > key)
		{
			parentBTNP = tempBNTP;
			tempBNTP = tempBNTP->LeftNode;
			isLeft = true;
		}
		else if (*(char*)tempBNTP->data < key)
		{
			parentBTNP = tempBNTP;
			tempBNTP = tempBNTP->RightNode;
			isLeft = false;
		}
		else
		{
			break;
		}
	}

	if (!tempBNTP)
	{
		cout << "not found this key!!" << endl;
		return;
	}

	cout << "found this key!!" << endl;

	// 第二步 : 我们得处里key结点没有父结点的情况
	if (!parentBTNP)
	{
		delete (char *)btnp->data;
		btnp->data = NULL;

		delete btnp;
		btnp = NULL;

		cout << "test" << endl;

		return;
	}
	else
	{
		// 第三步 : 我们得处里key结点有父结点的4种情况

		// 情况1
		if (tempBNTP->LeftNode == NULL && tempBNTP->RightNode == NULL)
		{
			if (isLeft)
			{
				parentBTNP->LeftNode = NULL;
			}
			else
			{
				parentBTNP->RightNode = NULL;
			}
		}
		// 情况2
		else if (tempBNTP->LeftNode == NULL)
		{
			if (isLeft)
			{
				parentBTNP->LeftNode = tempBNTP->RightNode;
			}
			else
			{
				parentBTNP->RightNode = tempBNTP->RightNode;
			}
		}
		// 情况3
		else if (tempBNTP->RightNode == NULL)
		{
			if (isLeft)
			{
				parentBTNP->LeftNode = tempBNTP->LeftNode;
			}
			else
			{
				parentBTNP->RightNode = tempBNTP->LeftNode;
			}
		}
		// 情况4
		else if (tempBNTP->LeftNode != NULL && tempBNTP->RightNode != NULL)
		{
			// 情况4比较复杂, 我们得找到key结点的后继
			// (后继 : 一个结点x的后继是大于x.key的最小关键字的结点)
			// 因为情况4中的key结点左孩子和右孩子都不为空, 
			// 所以key结点的后继 successorBTNP 肯定位于key结点的右子树中,
			// 且 successorBTNP 没有左孩子( 不然 successorBTNP 的左孩子就是key结点的后继了嘛)
			BTNP tempTempBNTP = tempBNTP->RightNode;

			// key结点的后继
			BTNP successorBTNP = NULL;

			// key结点的后继的父结点
			BTNP successorParentBTNP = NULL;

			while (tempTempBNTP)
			{
				successorBTNP = tempTempBNTP;
				if (tempTempBNTP && tempTempBNTP->LeftNode && tempTempBNTP->LeftNode->LeftNode == NULL)
				{
					successorParentBTNP = tempTempBNTP;
				}
				tempTempBNTP = tempTempBNTP->LeftNode;
			}

			// 情况4又分两种情况, 如下 : 
			// 第一种情况 A 是 successorBTNP 是 key 的右孩子;
			// 第二种情况 B 是 successorBTNP 在 key 的右子树中, 但并不是 successorBTNP 本身并不是 key 的右孩子

			// 情况 A : 
			if (successorBTNP == tempBNTP->RightNode)
			{
				// 用 key 结点的后继 successorBTNP 来替代 key 结点
				if (isLeft)
				{
					parentBTNP->LeftNode = successorBTNP;
				}
				else
				{
					parentBTNP->RightNode = successorBTNP;
				}
			}
			// 情况 B :
			else
			{
				// 如果 successorBTNP 有右子树, 则用 successorBTNP 的右子树 代替 原来 successorBTNP 的位置.
				if (successorBTNP->RightNode)
				{
					successorParentBTNP->LeftNode = successorBTNP->RightNode;
				}

				// 用 key 结点的后继 successorBTNP 的data来替换 key 结点的data
				char * tempChar = new char;
				*tempChar = *(char *)successorBTNP->data;
				tempBNTP->data = tempChar;
				tempBNTP = successorBTNP;

				// 下面注释的这块代码可以用上面这两4行代替
				// if (isLeft)
				// {
				// 	parentBTNP->LeftNode = successorBTNP;
				// 	successorBTNP->RightNode = tempBNTP->RightNode;
				// 	successorBTNP->LeftNode = tempBNTP->LeftNode;
				// }
				// else
				// {
				// 	parentBTNP->RightNode = successorBTNP;
				// 	successorBTNP->RightNode = tempBNTP->RightNode;
				// 	successorBTNP->LeftNode = tempBNTP->LeftNode;
				// }
			}

		}

		// 记得释放 key 结点
		delete (char *)tempBNTP->data;
		tempBNTP->data = NULL;

		delete tempBNTP;
		tempBNTP = NULL;
	}
}

```

# 参考

<< 算法导论 >>