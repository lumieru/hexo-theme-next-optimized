---
title: 游戏网络开发四之基于UDP的可靠性与排序和避免拥堵
date: 2016-11-17 22:20:34
tags:
- udp
- gafferongames
categories:
- server
---


[原文出处](https://gafferongames.com/post/reliability_ordering_and_congestion_avoidance_over_udp//)

[译文出处](http://gad.qq.com/program/translateview/7161834)




<div class="WordSection1"><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-family: 微软雅黑, sans-serif; font-size: 12pt; line-height: 150%;">翻译：艾涛（轻描一个世界） </span><span style="font-family: 微软雅黑, sans-serif; font-size: 12pt; line-height: 150%;">  </span><span style="font-family: 微软雅黑, sans-serif; font-size: 12pt; line-height: 150%;">审校：黄威（横写丶意气风发）</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><br  /></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b style="line-height: 1.5;"><span style="line-height: 40px; font-size: 20pt; font-family: 微软雅黑, sans-serif; color: rgb(34, 34, 34); border: 1pt none windowtext; padding: 0cm;">简介</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>嗨，我是格伦<span>-</span>菲德勒，欢迎来到我的</span><span><a rel='nofollow' href="http://gafferongames.com/networking-for-game-programmers/"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:red'><span>游戏程序员网络设计</span></span></a></span><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>文章系列的第四篇。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>在</span><span><a rel='nofollow' href="http://gafferongames.com/networking-for-game-programmers/virtual-connection-over-udp/"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:red'><span>之前的文章</span></span></a></span><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>里，我们将我们的虚拟连接的概念加入到<span>UDP</span>之上。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>现在我们将要给我们的虚拟<span>UDP</span>连接增加可靠性，排序和避免拥堵。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这是迄今为止底层游戏网络设计中最复杂的一面，因此这将是一篇</span><span style="font-size: 12pt; line-height: 150%; font-family: 微软雅黑, sans-serif;">极其热情</span><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>的文章，跟上我启程出发！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'> </span><img src="http://gameweb-img.qq.com/gad/20160617/phpYxViiW.1466148040.jpg" alt="游戏网络开发(四)：基于UDP的可靠性，排序和避免拥堵"  style="line-height: 1.5;"  /></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style='font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>TCP</span></b><b><span style='font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>的问题</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>熟悉<span>TCP</span>的你们知道它已经有了自己关于连接、可靠性、排序和避免拥堵的概念，那么为什么我们还要重写我们自己的迷你版本的基于<span>UDP</span>的<span>TCP</span>呢？</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>问题是多人动作游戏依靠于一个稳定的每秒发送<span>10</span>到<span>30</span>包的数据包流，而且在大多数情况下，这些数据包中包含的数据对时间是如此敏感以至于只有最新的数据才是有用的。这包括玩家的输入，位置方向和每个玩家角色的速度以及游戏世界中物理对象的状态等数据。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>TCP</span><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>的问题是它提取的是以可靠有序的数据流发送的数据。正因为如此，如果一个数据包丢失了，<span>TCP</span>不得不停止以等待那个数据包重新发送，这打断了这个稳定的数据包流因为更多的最新的数据包在重新发送的数据包到达之前必须在队列中等待，所以数据包必须有序地提供。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>我们需要的是一种不同类型的可靠性。我们想要以一个稳定的速度发送数据包而且当数据被其他电脑接收到时我们会得到通知，而不是让所有的数据用一个可靠有效的数据流处理。这样的方法使得那些对时间敏感的数据能够不用等待重新发送的数据包就通过，而让我们自己拿主意怎么在应用层级去处理丢包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>具有<span>TCP</span>这些特性的系统是不可能实现可靠性的，</span><span style="font-size: 12pt; line-height: 150%; font-family: 微软雅黑, sans-serif;">因此我们别无选择只能在<span>UDP</span>的基础上自行努力。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>不幸的是，可靠性并不是唯一一个我们必须重写的东西，这是因为<span>TCP</span>也提供避免拥堵功能，这样它就能够动态地衡量数据发送速率以来适应网络连接的性能。例如<span>TCP</span>在<span>28.8k</span>的调制调解器上会比在<span>T1</span>线路上发送更少的数据，而且它在不用事先知道这是什么类型的网络连接的情况下就能这么做！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222'> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style='font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>序列号</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>现在回到可靠性！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>我们可靠性系统的目标很简单：我们想要知道哪些数据包到了网络连接的另一端。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>首先我们得鉴别数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>如果我们添加一个“数据包<span>id</span>”的概念会怎么样？让我们先给<span>id</span>赋一个整数值。我们能够从零开始，然后随着我们每发送一个数据包，增加一个数值。我们发送的第一个数据包就是“包<span>0</span>”，发送的第<span>100</span>个数据包就是“包<span>99</span>”。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这实际上是一个相当普遍的技术。甚至于在<span>TCP</span>中也得到了应用！这些数据包<span>id</span>叫做序列号，然而我们并不打算像<span>TCP</span>那样去做来实现可靠性，使用相同的术语是有意义的，因此从现在起我们还将称之为序列号。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>因为<span>UDP</span>并不能保证数据包的顺序，所以第<span>100</span>个收到的数据包并不一定是第<span>100</span>个发出的数据包。接下来我们需要在数据包中插入序列号这样网络连接另一端电脑便能够知道是哪个数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>我们在</span><span><a rel='nofollow' href="http://gafferongames.com/networking-for-game-programmers/virtual-connection-over-udp/"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#C00000'><span>前一篇文章</span></span></a></span><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#C00000'>中</span><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>已经有了一个简单的关于虚拟网络连接的数据头，因此我们将只需要像这样在数据头中插入序列号：</span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222'>   [uint protocol id]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222'>   [uint sequence]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><i><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>(packet data…)</span></i></p></div><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>现在当其他电脑收到一个数据包时通过发送数据包的电脑它就能知道数据包的序列号啦。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style='font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>应答系统</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>既然我们已经能够使用序列号来鉴别数据包，下一步就该是让网络连接的另一端知道我们收到了哪个包了。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>逻辑上来说这是非常简单的，我们只需要记录我们收到的每个包的序列号，然后把那些序列号发回发送他们的电脑即可。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>因为我们是在两个机器间相互发送数据包，我们只能在数据包头添加上确认字符，就像我们加上序列号一样：</span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222'>    [uint protocol id]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222'>    [uint sequence]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222'>    [uint ack]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><i><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>(packet data…)</span></i></p></div><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>我们的一般方法如下：</span></p><ul type="disc"><li class="MsoNormal" style="text-align:left;line-height:150%;vertical-align:     baseline"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>每次我们发送一个数据包我们就增加本地序列号。</span></li><li class="MsoNormal" style="text-align:left;line-height:150%;vertical-align:     baseline"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>当我们接收一个数据包时，我们将这个数据包的序列号与最近收到的数据包的序列号(称之为远程序列号)进行核对。如果这个包时间更近，我们就更新远程序列号使之等于这个数据包的序列号。</span></li><li class="MsoNormal" style="text-align:left;line-height:150%;vertical-align:     baseline"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>当我们编写数据包头时，本地序列号就变成了数据包的序列号，而远程序列号则变成确认字符。</span></li></ul><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这个简单的应答系统工作条件是每当我们发出一个数据包就会接收到一个数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>但如果数据包一起发送这样在我们发送一个数据包之前有两个数据包到达该怎么办呢？我们每个数据包只留了一个确认字符的位置，那我们该怎么处理呢<span>?</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>现在考虑网络连接中的一端用更快的速率发送数据包这种情况。如果客户端每秒发送<span>30</span>个数据包，而服务器每秒只发送<span>10</span>个数据包，这样从服务器发出的每个数据包我们至少需要<span>3</span>个确认字符。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>让我们想得更复杂点！</span><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>如果数据包留下来了而确认字符丢失了会怎么样？这<span style="color:#222222">样发送这个数据包的电脑会认为这个数据包已经丢失了而实际上它已经被收到了！</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>貌似我们需要让我们的可靠性系统……<span style="border:none windowtext 1.0pt;padding:0cm">更加可靠一点！</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style='font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>可靠的应答系统</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这就是我们偏离<span>TCP</span>的地方。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>TCP</span><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>的做法是在确认字符发送的地方给下一个按顺序预期该收到的数据包序列号的位置维持一个移动窗口。<span style="color:#222222">如果<span>TCP</span>对于一个已经发出的数据包没有收到确认字符，它将暂停并重新发送那个对应序列号的数据包。这正是我们想要避免的做法！</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>因此在我们的可靠性系统里，我们从不为一个已经发出的序列号重新发送数据包，我们精确地只排序一次<span>n</span>，然后我们发送<span>n+1</span>，<span>n+2</span>，依次类推。如果数据包<span>n</span>丢失了我们也从不暂停重新发送它，而是把它留给应用程序来编写一个包含丢失数据的新的数据包，必要的话，这个包还会用一个新的序列号发送。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>因为我们工作的方式与<span>TCP</span>不同，</span><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>它的做法现在可能在我们数据包的确定字符设置中有了个洞，<span style="color:#222222">因此现在仅仅陈述最近的数据包的序列号已经远远不够了。</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>我们需要在每个数据包中包含多个确认字符。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>那我们需要多少确认字符呢<span>?</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>正如之前提到网络连接的一端发包速率比另一端快的情况，让我们假定最糟的情况是一端每秒钟发送不少于<span>10</span>个数据包，而另一端每秒钟发送不多于<span>30</span>个数据包。这种情况下，我们每个数据包需要的平均确认字符数是<span>3</span>个，但是如果数据包发送密集点，我们将需要更多。让我们说<span>6-10</span>个最差的情况。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>如果因为包含确认字符的数据包丢失而导致确认字符并没有到达怎么办<span>?</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>为了解决这个问题，我们将要使用一种经典的使用冗余码的网络设计策略来处理数据包丢失的情况！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>让我们在每个数据包中容纳<span>33</span>个确认字符，而且这不仅是他将要达到<span>33</span>个，而是一直是<span>33</span>个。因此对于每一个发出的确认字符我们多余地把它额外多发送了多达<span>32</span>次，仅仅是以防某个包含确认字符的数据包不能通过！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>但是我们怎么可能在一个数据包里配置<span>33</span>个确认字符呢？每个确认字符<span>4</span>字节那就是<span>132</span>字节了！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>窍门是在“相应确认字符”之前使用一段位域来代表<span>32</span>个之前的确认字符<span style="color:#222222">，就像这样</span></span><span style="font-size:12.0pt;line-height:150%;font-family:宋体;color:#222222">：</span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>   [uint protocol id]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>   [uint sequence]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>   [uint ack]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>   [uint ack bitfield]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><i><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>(packet data…)</span></i></p></div><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>我们这样规定“位域”中每一位对应“相应确认字符”之前的<span>32</span>个确认字符<span style="color:#222222">。因此让我们说“相应确认字符”是<span>100</span>。如果位域的第一位设置好了，那么这个数据包也包含包<span>99</span>的一个确认字符。如果第二位设置好了，那么它也包含包<span>98</span>的一个确认字符。这样一路下来就到了包<span>68</span>的第<span>32</span>位。</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>我们调整过的算法看起来就像这样<span>:</span></span></p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style='font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:windowtext'>每次我们发送一个数据包我们就增加本地序列号</span><span style='font-size:12.0pt;line-height:150%;font-family:&quot;quot;微软雅黑&quot;,&quot;sans-serif&quot;'>。</span></li><li class="MsoNormal" style="text-align:left;line-height:150%;vertical-align:     baseline"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>当我们接收一个数据包时，我们将这个数据包的序列号与最近收到的数据包的序列号(称之为远程序列号)进行核对。如果这个包是更新的，我们就更新远程序列号使之等于数据包的序列号。</span></li><li class="MsoNormal" style="text-align:left;line-height:150%;vertical-align:     baseline"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>当我们编写数据包头时，本地序列号就变成了数据包的序列号，而远程序列号则变成确认字符<span style="color:#222222">。 计算确认字符位域是通过寻找一个多达<span>33</span>个数据包的队列，其中包括在<span>[</span>远程序列号<span>-32</span>，远程序列号<span>]</span>范围内的序列号。</span>如果序列号“远程序列号<span>-n</span>”正在接收队列中那就把确认字符位域中的位<span>n</span>（在<span>[1</span>，<span>32]</span>范围内）设置为位<span>1</span>。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style='font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:windowtext'>此外，当一个数据包被接收了，确认字符位域也被扫描了，如果位<span>n</span>设置好了，那么即使它还没有被应答，我们也认可序列号“远程序列号<span>-n</span>”</span><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>。</span></li></ul><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>利用这个改善过的算法，你将可能不得不在不止一秒内丢掉<span>100%</span>的数据包而不是让一个数据包停止通过。当然，它能够轻松地处理不同的发包速率和接受一起发送的数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style='font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>检测丢包</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>既然我们知道网络连接另一端接受的是哪些数据包，那么我们该怎么检测数据包的丢失呢<span>?</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这次的窍门是反过来想，如果你在一定时间内还没有收到某个数据包的应答，那么我们可以考虑说那个数据包已经丢失了。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>考虑到我们正在以每秒不超过<span>30</span>包的速率发送数据包，而且我们正在多余地发送数据包大概三十次。如果你在一秒内没有收到某个数据包的确认字符，那很有可能就是这个数据包已经丢失了。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>因此我们在这儿用了一些小窍门，尽管我们能<span>100%</span>确定哪个数据包通过了，但是我们只能适度地确定那些没有到达的数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这种情况的复杂性在于任何你重新发送的使用了这种可靠性方法的数据需要有它自己的信息<span>id</span>，这样的话在你多次收到它的时候你可以放弃它。这在应用层级是能够做到的。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>应对环绕式处理的序列号</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>如果序列号没有环绕式处理覆盖，那么对于序列号和确认字符的讨论是不完整的！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>序列号和确认字符都是<span>32</span>比特的无符号整数，因此它们能够代表在范围<span>[0</span>，<span>4294967295]</span>内的数字。那是一个非常大的数字！那么大以至于如果你每秒发送三十个数据包也将要花费四年半来把这个序列号环绕式处理回零。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>但是可能你想要节省一些带宽这样你将你的序列号和确认字符缩减到到<span>16</span>比特整数。你每个数据包节省了<span>4</span>个字节，但现在他们只需要在仅仅半个小时内即可完成环绕式处理！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>所以我们该怎么应对这种环绕式处理的情况呢<span>?</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>诀窍是要认识到如果当前序列号已经非常高了，而且下一个到达的序列号很低，那么你就必须进行环绕式处理。那么即使新的序列号数值上比当前序列号值更低它也能实际代表一个更新的数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>举个例子，让我们假设我们用一个字节编码序列号（顺便说一下并不推荐这样做）。<span> :))</span>， 之后他们就会在<span>255</span>后面进行环绕式处理，就像这样</span><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222'>:</span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222'>   … 252, 253, 254, 255, 0, 1, 2, 3,…</span></p></div><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>为了解决这种情况我们需要一个能够意识到在<span>255</span>之后需要环绕式处理回零这样一个事实的新功能，这样<span>0</span>，<span>1</span>，<span>2</span>，<span>3</span>就会被认为比<span>255</span>更新。否则，我们的可靠性系统就会在你收到包<span>255</span>后停止工作。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这就是那个新功能：</span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>boolsequence_more_recent( unsigned int s1, </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>                          unsigned int s2,</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>                          unsigned int max )</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>{</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>   return </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>       ( s1 &gt; s2 ) &amp;&amp;</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>       ( s1 - s2 &lt;= max/2 ) </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>          ||</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>       ( s2 &gt; s1 ) &amp;&amp;</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>       ( s2 - s1  &gt; max/2 );</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>}</span></p></div><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这个功能通过比较两个数字和他们的不同来工作。如果它们之间的差异少于<span>1/2</span>的最大序列号值，那么它们必须靠在一起<span>– </span>因此我们只需要照常检查某个序列号是否比另一个大。然而，如果它们相差很多，它们之间的差异将会比<span>1/2</span>的最大序列号值大，那么如果它比当前序列号小我们反而认为这个序列号是更新的。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这最后一点是显然需要环绕式处理序列号的地方，那么<span>0</span>，<span>1</span>，<span>2</span>就会被认为比<span>255</span>更新。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>多么简洁而巧妙！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>一定要确保你在你所做的任何序列号处理当中包含了这一步！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style='font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>避免拥堵</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>当你已经解决了可靠性的问题的时候，还有避免拥堵的问题。当你获得<span>TCP</span>的可靠性的时候<span>TCP</span>已经提供了避免拥堵的功能作为数据包的一部分，但是<span>UDP</span>无论怎样都不会有避免拥堵！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>如果我们仅仅发送数据包而没有某种流量控制，我们正在冒险占满网络连接而且会引起严重的延迟（<span>2</span>秒以上！），正如我们和另外一台电脑之间的路由器会超负荷而缓冲数据包。这个发生是因为路由器很努力地想要尝试传送我们发送的所有数据包，因此在它们考虑丢弃数据包之前会在队列中缓冲数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>然而如果我们能告诉路由器我们的数据包是时间敏感的而且如果路由器超载的话这些数据包应该丢弃而不是缓冲这样会很棒的，但只有我们重写世界上所有路由器的软件才能做到这一点！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>那么我们反而需要把重点放在我们实际上能做的是<u>避免占满首位网络连接</u>。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>做到这个的方法是实施我们自己的基础避免拥堵算法。我强调基础！就像可靠性，我们并不寄希望于像<span>TCP</span>第一次尝试应用那样普通而粗暴地想出某些东西，那么让我们让它尽可能简单吧。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style='font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>衡量往返时间</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>因为所有避免拥堵的要点就是避免占满网络连接和增加往返时间（<span>RTT</span>），关于我们是不是占满网络的最重要的衡量标准是<span>RTT</span>它本身的观点是有道理的。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>我们需要一种方法来衡量我们网络连接的<span>RTT</span>。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这是基础的技巧：</span></p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style='font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>对我们发送的每个数据包，我们对数据包队列中包含的序列号和他们发送的时间添加一个登记。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style='font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:windowtext'>当我们收到一个应答时，我们找到这个登记, 然后记录我们收到这个应答的时间t1与我们发送数据包的时间的t2的差值(都基于本地时间来计算)。这就是是这个数据包的<span>RTT</span>时间</span><span style='font-size:12.0pt;line-height:     150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style='font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>因为数据包的到达因网络波动而不同，我们需要缓和这个值来提供某些有意义的东西，这样每次我们获得一个新的<span>RTT</span>我们就移动一个我们当前的<span>RTT</span>和数据包的<span>RTT</span>之间距离的百分比。<span>10%</span>在实践中看起来效果很好。这就叫做一个指数级平滑移动平均值，而且它在用一个低通滤波器的情况下能有效地平滑<span>RTT</span>中的杂音。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style='font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>为了确保发送队列永不增长，一旦超过某些最大预期<span>RTT</span>值我们就丢弃数据包。正如上一节关于可靠性讨论过的，任何在一秒内未应答的数据包都极有可能丢失了，那么对于最大<span>RTT</span>来说，一秒是个很棒的值。</span></li></ul><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>既然我们有<span>RTT</span>，我们能把它作为一个衡量标准来推动我们的避免拥堵功能。如果<span>RTT</span>变得太大了，我们更缓慢地发送数据，如果它的值低于可接受范围，我们能努力更频繁地发送数据。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style='font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>简单的好坏机制避免拥堵</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>正如之前讨论的，我们不要那么贪心，我们将要执行一个非常基础的避免拥堵机制。这个避免拥堵机制有两种模式。好和坏。我把它叫做简单的二进制避免拥堵。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>让我们假设你在发送一个确定大小的数据包，就假设<span>256</span>字节吧。你想要每秒发送这些数据包<span>30</span>次，但是如果网络条件差，你可以削减为每秒<span>10</span>次。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>那么<span>30</span>次<span>256</span>字节的数据包的速率大概是<span>64kbits/sec</span>，每秒<span>10</span>次的话大概<span>20kbits/sec</span>。世界上没有一个宽带连接不能处理至少<span>20kbits/sec</span>的速率，所以我们在这样的假定下继续前进。不像<span>TCP</span>这样对有任何数量的发送<span>/</span>接受带宽的任何设备都完全通用，我们将假设一个设备的最小支持带宽来参与我们的网络连接。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>所以基础想法就是这样了。当网络条件好的时候我们每秒发送<span>30</span>个数据包，当网络条件差的时候我们降至每秒<span>10</span>个数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>当然，你能随你喜爱定义好和坏，但是仅考虑<span>RTT</span>的时候我已经得到了好的成效。举个例子，如果<span>RTT</span>超过某些极限值（假设<span>250ms</span>）那你就知道你可能已经正占满了网络连接。当然，这里假设一般没人在非占满网络条件下超过<span>250ms</span>，考虑到我们的宽带要求这是合理的。。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>好和坏之间你会怎么转换？我喜欢用下列操作的算法<span>:</span></span></p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style='font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>如果你当前在好模式下，而网络条件突然变坏，立即降至坏模式。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style='font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>如果你正在坏模式下，而且网络条件已经好了一段特定时长<span>”t”</span>，那么回到好模式。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style='font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>为了避免好模式和坏模式之间的快速切换，如果你从好模式降至坏模式持续<span>10</span>秒钟以内，从坏模式回到好模式之前的时间是<span>”t”</span>的两倍。在某些最大值中固定这个时间值，假设<span>60</span>秒。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style='font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:windowtext'>当它们有一小段时期的差连接时，为了避免打击良好的网络连接，每过<span>10</span>秒连接就处于好模式，把坏模式回到好模式之前的时间<span>“t”</span>减半。在某些最小值中固定这个时间值，例如<span>1</span>秒</span><span style='font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>。</span></li></ul><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>利用这个算法，你将对差网络连接迅速反应然后降低你的发送速率至每秒<span>10</span>个数据包，避免占满网络。在网络条件好时，你也将谨慎地尝试好模式，坚持以更高的每秒发送<span>30</span>个数据包的速率发送数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>当然，你也能实施复杂得多的算法，丢包率百分比甚至是网络波动（数据包确认字符的时间差异）都可以考虑作为一个衡量标准，而不仅仅是<span>RTT</span>。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>对于避免拥堵你还可以更贪心点，并尝试发现什么时候你能以一个更高的带宽（例如<span>LAN</span>）发送数据，但是你必须非常小心！随着贪婪心的增加你占满网络连接的风险也在增大！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style='font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm'>结语</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>我们全新的可靠性系统让我们稳定流畅发送数据包，而且能通知我们收到了什么数据包。从这我们能推断出丢失的数据包，必要的话重新发送没有通过的数据。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>基于此我们有了能够取决于网络条件在每秒<span>10</span>次和每秒<span>30</span>次发包速率间轮流切换的一个简单的避免拥堵系统，因此我们不会占满网络连接。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>还有很多实施细节因为太具体而不能在这篇文章一一提到，所以务必确保你检查</span><span><a rel='nofollow' href="http://netgame.googlecode.com/files/ReliabilityAndFlowControl.zip"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:red'><span>示例源代码</span></span></a></span><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>来看是否它都被实施了。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'>这就是关于可靠性，排序和避免拥堵的一切了，或许是低层次网络设计中最复杂的一面了。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222'> </span></p><p class="MsoNormal" style="line-height:150%"><br  /></p><p class="MsoNormal" style="line-height:150%">【版权声明】</p><p class="MsoNormal" style="line-height:150%"><span style='font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;'>原文作者未做权利声明，视为共享知识产权进入公共领域，自动获得授权；</span></span><span style='font-size:9.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333'> </span></p><p class="MsoNormal" align="left" style="text-indent: 24pt;"><span style='font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222'> </span></p></div>                    </div>
                </div>



# 源码下载

因 Gaffer On Games 的源码原下载地址失效, 所以特地补上.

[请点击](https://github.com/no5ix/ReliableUDP)