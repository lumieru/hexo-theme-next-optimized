---
title: 排序算法四之谈一谈堆排序
date: 2014-08-24 13:48:14
tags:
- 排序
- c++
categories:
- c++
---

# 堆排序的复杂度

- **MaxHeapify** : O(logN)
- **BuildMaxHeap** : O(N)
- 所以 **HeapSort** (堆排序)的复杂度是 : O(NlogN)

# MaxHeapify

具体过程如下图 : 

{% asset_img MaxHeapify.png MaxHeapify %}

```  c++
void MaxHeapify(int arr[], int index, int length)
{
	if (!arr || index < 0 || length <= 0)
	{
		cout << "error" << endl;
		return;
	}

	int tempData = 0;
	int leftChildIndex = 0;
	int rightChildIndex = 0;
	int largestIndex = 0;
	while (1)
	{
		leftChildIndex = index * 2 + 1;
		rightChildIndex = index * 2 + 2;

		largestIndex = index;

		if (leftChildIndex < length && arr[largestIndex] < arr[leftChildIndex])
		{
			largestIndex = leftChildIndex;
		}

		if (rightChildIndex < length && arr[largestIndex] < arr[rightChildIndex])
		{
			largestIndex = rightChildIndex;
		}
		if (largestIndex != index)
		{
			tempData = arr[index];
			arr[index] = arr[largestIndex];
			arr[largestIndex] = tempData;

			index = largestIndex;
		}
		else
		{
			break;
		}
	}
}
```

# BuildMaxHeap

因为 c++ 数组的 index 是从0开始的(跟上图中有所不同, 图中的 index 是从1开始的), 
而根据算法导论中的结论我们可以知道数组中 index 大于等于 length/2 的元素都是树的叶结点,
所以我们对每一个不是叶结点的元素(即为 index 小于等于 length/2 - 1 的元素 )自底向上调用一次 MaxHeapify 就可以把一个大小为 length 的数组转换为最大堆. 

```  c++
void BuildMaxHeap(int arr[], int length)
{
	if (!arr || length <= 0)
	{
		cout << "error" << endl;
		return;
	}
	for (int index = length / 2 - 1; index >= 0; --index)
	{
		MaxHeapify(arr, index, length);
	}
}
```

# HeapSort

具体过程如下图 : 

{% asset_img HeapSort1.png %}
{% asset_img HeapSort2.png HeapSort %}

```  c++
void HeapSort(int arr[], int length)
{
	if (!arr || length <= 0)
	{
		cout << "error" << endl;
		return;
	}
	BuildMaxHeap(arr, length);

	int tempData = 0;
	for (int index = length - 1; index >= 1; --index)
	{
		tempData = arr[index];
		arr[index] = arr[0];
		arr[0] = tempData;

		MaxHeapify(arr, 0, --length);
	}
}
```