---
title: 数据结构二之二叉树的遍历和交换左右孩子
date: 2014-09-23 12:11:22
tags:
- 二叉树
- c++
categories:
- c++
---

二叉树的二叉链式存储方案的代码表示：

``` c++
typedef struct BinaryTreeNode
{
	void *data;
	BinaryTreeNode *LeftNode;
	BinaryTreeNode *RightNode;
}BTN, *BTNP;
```



# 二叉树的遍历

![这里写图片描述](http://img.blog.csdn.net/20170805023144001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbm9zaXg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

如上图得到的相应的遍历的序列分别为：

 - 先(根)序遍历 ： ABCDEGF
 - 中(根)序遍历 ： CBEGDFA
 - 后(根)序遍历 ： CGEFDBA

<!-- more --> 

## 递归遍历
``` c++

void PreOrderTraverse_Recursion(BTNP btnp)
{
	if (btnp)
	{
		cout << *(char *)btnp->data << endl;
		PreOrderTraverse_Recursion(btnp->LeftNode);
		PreOrderTraverse_Recursion(btnp->RightNode);
	}
}

void InOrderTraverse_Recursion(BTNP btnp)
{
	if (btnp)
	{
		PreOrderTraverse_Recursion(btnp->LeftNode);
		cout << *(char *)btnp->data << endl;
		PreOrderTraverse_Recursion(btnp->RightNode);
	}
}

void PostOrderTraverse_Recursion(BTNP btnp)
{
	if (btnp)
	{
		PreOrderTraverse_Recursion(btnp->LeftNode);
		PreOrderTraverse_Recursion(btnp->RightNode);
		cout << *(char *)btnp->data << endl;
	}
}


```

## 迭代遍历

迭代的二叉树三种遍历方式其实思想是**统一**的 : 都是从左子树的各个结点依次入栈, 当左边已经走到头了, 就开始走右边, 在适当的条件就出栈, 只是每个遍历方式的出栈条件不一样而已.

看下面三种代码可以看出 : **前半段入栈的代码都差不多, 后半段出栈的代码不太相同**

### 迭代先序遍历代码实现

``` c++

void PreOrderTraverse_Iteration(BTNP btnp)
{
	BTNP tempBTNP = btnp;
	stack<BTNP> stackBTNP;
	while (!stackBTNP.empty() || tempBTNP)
	{
		while (tempBTNP)
		{
			cout << *(char *)tempBTNP->data << endl;
			stackBTNP.push(tempBTNP);
			tempBTNP = tempBTNP->LeftNode;
		}
		if (!stackBTNP.empty())
		{
			tempBTNP = stackBTNP.top()->RightNode;
			stackBTNP.pop();
		}
	}
}
```

### 迭代中序遍历代码实现

``` c++

void InOrderTraverse_Iteration(BTNP btnp)
{
	BTNP tempBTNP = btnp;
	stack<BTNP> stackBTNP;
	while (!stackBTNP.empty() || tempBTNP)
	{
		while (tempBTNP)
		{
			stackBTNP.push(tempBTNP);
			tempBTNP = tempBTNP->LeftNode;
		}

		if (!stackBTNP.empty())
		{
			cout << *(char*)(stackBTNP.top()->data) << endl;
			tempBTNP = stackBTNP.top()->RightNode;
			stackBTNP.pop();
		}
	}
}
```

### 迭代后序遍历代码实现

后序遍历的出栈条件有点不一样, 因为后序是先左后右再中的, 比如某个结点p要出栈, 需要遍历完了p的所有右子树之后才能出栈, 而不能第一次就出栈, 所以专门构造了一个结构体F_bt来记录他是否是第一次出栈 (F_bt结构体里有个 isFirst 的数据来记录)

**所以我们代码中的思路就是 : **
把每个将要入栈的结点的 isFirst 标志都置为 true , 当第一次遍历到结点p的时候, 不使p出栈, 但使p的 isFirst 标志变为 false, 然后 "temp_btp = 栈顶->右孩子" 开始遍历他的右子树. 当p的右子树都遍历完了之后(也就是p的右子树都依次出栈了之后)又会遍历到p自己, 不过这一次他的 isFirst 标志已经为 false 了, 我们通过这个标志知道不是第一次遍历到p了, 所以这时我们使p出栈, 并且将 temp_btp 置为 NULL ( 因为此时p的右子树都已经遍历完了, 所以不用像之前一样再 "temp_btp = 栈顶->右孩子" 了 )

``` c++

void PostOrderTraverse_Iteration(BTNP btnp)
{
	typedef struct  
	{
		bool isFirst;
		BTNP btn_ptr;
	}Post_BTN, *Post_BTN_Ptr;

	BTNP tempBTNP = btnp;
	stack<Post_BTN_Ptr> stackPBP;

	while (!stackPBP.empty() || tempBTNP)
	{
		while (tempBTNP)
		{
			Post_BTN_Ptr tempPBP = new Post_BTN;
			tempPBP->isFirst = true;
			tempPBP->btn_ptr = tempBTNP;

			stackPBP.push(tempPBP);

			tempBTNP = tempBTNP->LeftNode;
		}

		if (!stackPBP.empty())
		{
			if (stackPBP.top()->isFirst)
			{
				stackPBP.top()->isFirst = false;
				tempBTNP = stackPBP.top()->btn_ptr->RightNode;
			}
			else
			{
				cout << *(char*)(stackPBP.top()->btn_ptr->data) << endl;

				delete stackPBP.top();
				stackPBP.top() = NULL;

				tempBTNP = NULL;

				stackPBP.pop();
			}
		}
	}
}

```


# 交换所有左右孩子

交换左右孩子用递归很容易做到

``` c++
void SwapBinaryTree(BTNP btnp)
{
	if (btnp)
	{
		BTNP tempBTNP = btnp->LeftNode;
		btnp->LeftNode = btnp->RightNode;
		btnp->RightNode = tempBTNP;

		SwapBinaryTree(btnp->LeftNode);
		SwapBinaryTree(btnp->RightNode);
	}
}
```
