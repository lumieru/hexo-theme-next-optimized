<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">

<script>
    (function(){
        if(''){
            if (prompt('Password') !== ''){
                alert('Error!');
                history.back();
            }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2" />






<meta name="description" content="以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.">
<meta property="og:type" content="website">
<meta property="og:title" content="烫">
<meta property="og:url" content="http://yoursite.com/page/13/index.html">
<meta property="og:site_name" content="烫">
<meta property="og:description" content="以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="烫">
<meta name="twitter:description" content="以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/13/"/>





  <title>烫 - 烫烫烫烫烫</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">烫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">烫烫烫烫烫</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/11/redis使用概要1之数据类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nosix">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/11/redis使用概要1之数据类型/" itemprop="url">redis使用概要1之数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-07-11T09:29:22+08:00">
                2015-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DB/" itemprop="url" rel="index">
                    <span itemprop="name">DB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis简介要义"><a href="#Redis简介要义" class="headerlink" title="Redis简介要义"></a>Redis简介要义</h1><ul>
<li><p>Redis运行在内存中但是可以持久化到磁盘, 重启的时候可以再次加载进行使用</p>
</li>
<li><p>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行</p>
</li>
<li><p>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作</p>
</li>
<li><p>Redis支持数据的备份，即master-slave模式的数据备份</p>
</li>
</ul>
<h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><blockquote>
<p>Redis的数据类型很重要, 这是他做很多事情的基础, 不理解的话很难用好</p>
</blockquote>
<h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h2><p>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，</p>
<p>一个key对应一个value。</p>
<p>string类型是二进制安全的。</p>
<p>二进制安全的意思是redis的string可以包含任何数据。</p>
<p>比如jpg图片或者序列化的对象 。</p>
<p>string类型是Redis最基本的数据类型，一个键最大能存储512MB。</p>
<p>实例 : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; SET name &quot;runoob&quot;</div><div class="line">OK</div><div class="line">redis 127.0.0.1:6379&gt; GET name</div><div class="line">&quot;runoob&quot;</div></pre></td></tr></table></figure>
<h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><p>Redis hash 是一个键名对集合。</p>
<p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<p>实例 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">127.0.0.1:6379&gt; HMSET user:1 username runoob password runoob points 200</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; HGETALL user:1</div><div class="line">1) &quot;username&quot;</div><div class="line">2) &quot;runoob&quot;</div><div class="line">3) &quot;password&quot;</div><div class="line">4) &quot;runoob&quot;</div><div class="line">5) &quot;points&quot;</div><div class="line">6) &quot;200&quot;</div></pre></td></tr></table></figure></p>
<p>以上实例中 hash 数据类型存储了包含用户脚本信息的用户对象。</p>
<p> 实例中我们使用了 Redis HMSET, HGETALL 命令，user:1 为键值。</p>
<p>每个 hash 可以存储 232 -1 键值对（40多亿）。</p>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。</p>
<p>你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>实例 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; lpush runoob redis</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; lpush runoob mongodb</div><div class="line">(integer) 2</div><div class="line">redis 127.0.0.1:6379&gt; lpush runoob rabitmq</div><div class="line">(integer) 3</div><div class="line">redis 127.0.0.1:6379&gt; lrange runoob 0 10</div><div class="line">1) &quot;rabitmq&quot;</div><div class="line">2) &quot;mongodb&quot;</div><div class="line">3) &quot;redis&quot;</div><div class="line">redis 127.0.0.1:6379&gt;</div></pre></td></tr></table></figure></p>
<p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>Redis的Set是string类型的无序集合。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<h3 id="sadd-命令"><a href="#sadd-命令" class="headerlink" title="sadd 命令"></a>sadd 命令</h3><p>添加一个string元素到,key对应的set集合中，成功返回1,</p>
<p>如果元素已经在集合中返回0,key对应的set不存在返回错误。</p>
<p><code>sadd key member</code></p>
<p>实例 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; sadd runoob redis</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; sadd runoob mongodb</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; sadd runoob rabitmq</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; sadd runoob rabitmq</div><div class="line">(integer) 0</div><div class="line">redis 127.0.0.1:6379&gt; smembers runoob</div><div class="line"></div><div class="line">1) &quot;rabitmq&quot;</div><div class="line">2) &quot;mongodb&quot;</div><div class="line">3) &quot;redis&quot;</div></pre></td></tr></table></figure></p>
<p>注意：以上实例中 rabitmq 添加了两次，</p>
<p>但根据集合内元素的唯一性，第二次插入的元素将被忽略。</p>
<p>集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</p>
<h2 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h2><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个double类型的分数。<br>redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>zset的成员是唯一的,但分数(score)却可以重复。</p>
<h3 id="zadd-命令"><a href="#zadd-命令" class="headerlink" title="zadd 命令"></a>zadd 命令</h3><p>添加元素到集合，元素在集合中存在则更新对应score<br><code>zadd key score member</code><br>实例 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; zadd runoob 0 redis</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; zadd runoob 0 mongodb</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq</div><div class="line">(integer) 1</div><div class="line">redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq</div><div class="line">(integer) 0</div><div class="line">redis 127.0.0.1:6379&gt; ZRANGEBYSCORE runoob 0 1000</div><div class="line"></div><div class="line">1) &quot;redis&quot;</div><div class="line">2) &quot;mongodb&quot;</div><div class="line">3) &quot;rabitmq&quot;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/22/socket可读可写条件与非阻塞connect或accept浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nosix">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/22/socket可读可写条件与非阻塞connect或accept浅析/" itemprop="url">socket可读可写条件与非阻塞connect或accept浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-06-22T21:56:12+08:00">
                2015-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="socket可读的条件"><a href="#socket可读的条件" class="headerlink" title="socket可读的条件: "></a><strong>socket可读的条件: </strong></h2><ol>
<li>socket的接收缓冲区中的数据字节大于等于该socket的接收缓冲区低水位标记的当前大小。对这样的socket的读操作将不阻塞并返回一个大于0的值(也就是返回准备好读入的数据)。我们可以用SO_RCVLOWATsocket选项来设置该socket的低水位标记。对于TCP和UDP .socket而言，其缺省值为1.</li>
<li>该连接的读这一半关闭(也就是接收了FIN的TCP连接)。对这样的socket的读操作将不阻塞并返回0</li>
<li><strong>给监听套接字准备好新连接</strong></li>
<li>有一个socket有异常错误条件待处理.对于这样的socket的读操作将不会阻塞,并且返回一个错误(-1),errno则设置成明确的错误条件.这些待处理的错误也可通过指定socket选项SO_ERROR调用getsockopt来取得并清除;</li>
</ol>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2015/06/22/socket可读可写条件与非阻塞connect或accept浅析/" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/20/关系型数据库与NoSQL的爱恨情仇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nosix">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/20/关系型数据库与NoSQL的爱恨情仇/" itemprop="url">关系型数据库与NoSQL的爱恨情仇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-05-20T13:18:17+08:00">
                2015-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DB/" itemprop="url" rel="index">
                    <span itemprop="name">DB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="NoSQL因关系数据库的不足而生"><a href="#NoSQL因关系数据库的不足而生" class="headerlink" title="NoSQL因关系数据库的不足而生"></a>NoSQL因关系数据库的不足而生</h1><p>随着互联网的不断发展，各种类型的应用层出不穷，所以导致在这个云计算的时代，</p>
<p>对技术提出了更多的需求，主要体现在下面这四个方面：</p>
<ul>
<li>低延迟的读写速度：应用快速地反应能极大地提升用户的满意度; </li>
<li>支撑海量的数据和流量：对于搜索这样大型应用而言，需要利用PB级别的数据和能应对百万级的流量; </li>
<li>大规模集群的管理：系统管理员希望分布式应用能更简单的部署和管理;</li>
</ul>
<p>庞大运营成本的考量：IT经理们希望在硬件成本、软件成本和人力成本能够有大幅度地降低;</p>
<p>目前世界上主流的存储系统大部分还是采用了关系型数据库，其主要有一下优点：</p>
<ul>
<li>事务处理—保持数据的一致性；</li>
<li>由于以标准化为前提，数据更新的开销很小（相同的字段基本上只有一处）；</li>
<li>可以进行Join等复杂查询。</li>
</ul>
<p>虽然关系型数据库已经在业界的数据存储方面占据不可动摇的地位，但是由于其天生的几个限制，</p>
<p>使其很难满足上面这几个需求： </p>
<ul>
<li>扩展困难：由于存在类似Join这样多表查询机制，使得数据库在扩展方面很艰难; </li>
<li>读写慢：这种情况主要发生在数据量达到一定规模时由于关系型数据库的系统逻辑非常复杂，使得其非常容易发生死锁等的并发问题，所以导致其读写速度下滑非常严重; </li>
<li>成本高：企业级数据库的License价格很惊人，并且随着系统的规模，而不断上升; </li>
<li>有限的支撑容量：现有关系型解决方案还无法支撑Google这样海量的数据存储; </li>
</ul>
<blockquote>
<p>业界为了解决上面提到的几个需求，推出了多款新类型的数据库，并且由于它们在设计上和传统的NoSQL数据库相比有很大的不同，<br>所以被统称为“NoSQL”系列数据库。</p>
</blockquote>
<p>总的来说，在设计上，它们非常关注对数据高并发地读写和对海量数据的存储等，与关系型数据库相比，它们在架构和数据模型方量面做了“减法”，</p>
<p>而在扩展和并发等方面做了“加法”。</p>
<blockquote>
<p>现在主流的NoSQL数据库有<strong>MongoDB</strong>和<strong>Redis</strong>以及BigTable、Hbase、Cassandra、SimpleDB、CouchDB、等。</p>
</blockquote>
<p>接下来，将关注NoSQL数据库到底存在哪些优缺点。</p>
<h1 id="NoSQL的优缺点"><a href="#NoSQL的优缺点" class="headerlink" title="NoSQL的优缺点"></a>NoSQL的优缺点</h1><p>在优势方面，主要体现在下面这三点： </p>
<ul>
<li>简单的扩展：典型例子是Cassandra，由于其架构是类似于经典的P2P，所以能通过轻松地添加新的节点来扩展这个集群; </li>
<li>快速的读写：主要例子有redis，由于其逻辑简单，而且纯内存操作，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作; </li>
<li>低廉的成本：这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本; </li>
</ul>
<p>但瑕不掩瑜，NoSQL数据库还存在着很多的不足，常见主要有下面这几个： </p>
<ul>
<li>不提供对SQL的支持：如果不支持SQL这样的工业标准，将会对用户产生一定的学习和应用迁移成本; </li>
<li>支持的特性不够丰富：现有产品所提供的功能都比较有限，大多数NoSQL数据库都不支持事务，也不像MS SQL Server和Oracle那样能提供各种附加功能，比如BI和报表等; </li>
<li>现有产品的不够成熟：大多数产品都还处于初创期，和关系型数据库几十年的完善不可同日而语; </li>
</ul>
<p>上面NoSQL产品的优缺点都是些比较共通的，在实际情况下，每个产品都会根据自己所遵从的数据模型和CAP理念而有所不同.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/03/C++对象模型之详述C++对象的内存布局/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nosix">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/03/C++对象模型之详述C++对象的内存布局/" itemprop="url">C++对象模型之详述C++对象的内存布局</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-05-03T12:05:48+08:00">
                2015-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post"><br><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;"><span style="font-size:14px;">在</span><a target="_blank" href="http://blog.csdn.net/ljianhui/article/details/45903939"><span style="color: rgb(255, 0, 0);"><span style="font-size:18px;">C++对象模型之简述C++对象的内存布局</span></span></a><span style="font-size:14px;">一文中，详细分析了各种成员变量和成员函数对一个类（没有任何继承的）对象的内存分布的影响，及详细讲解了如何遍历对象的内存，包括虚函数表。如果你在阅读本文之前，还没有看过C++对象模型之简述C++对象的内存布局一文，建议先阅读一下。而本文主要讨论继承对于对象的内存分布的影响，包括：继承后类的对象的成员的布局、继承对于虚函数表的影响、virtual函数机制如何实现、运行时类型识别等。由于在C++中继承的关系比较复杂，所以本文会讨论如下的继承情况：</span></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">1）单一继承</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">2）多重继承</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">3）重复继承</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">4）单一虚拟继承</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">5）钻石型虚拟继承</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">此外，当一个类作为一个基类时，它的析构函数应该是virtual函数，这样下面的代码才能正确地运行</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">Base <em>p = new&nbsp;Derived;</em></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">…</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">delete p;</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">在本文的例子，为了验证虚函数表的内容，会遍历并调用虚函数表中的所有函数。但是当析构函数为virtual时，在遍历的过程中就会调用到对象的析构函数，从而对对象进行析构的操作，导致接下来的调用出错。但是本文的目的是分析和验证C++对象的内存布局，而不是设计一个软件，析构函数为非virtual函数，并不会影响我们的分析和理解，因为virtual析构函数与其他的virtual函数是一样的，只是做的事不一样。所以在本文中的例子中，析构函数均不为virtual，特此说明一下。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">同时为了调用的方便，所有的virtual的函数原型均为：返回值为void，参数也为void。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">注：以下的例子中的测试环境为：32位Ubuntu 14.04 g++ 4.8.2，若在不同的环境中进行测试，结果可能有不同。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="color:#ff0000;background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;">1、根据指向虚函数表的指针（vptr）遍历虚函数表</span></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">由于在访问对象的内存时，都要遍历虚函数表来确定虚函数表中的内容，所以对这部分的功能抽象出来，写成一个函数，如下：</span></div><div style="line-height: 21px;"><span style="font-family: 'Microsoft YaHei';font-size:14px;"></span><pre name="code" class="cpp">void visitVtbl(int **vtbl, int count)<br>{<br>    cout &lt;&lt; vtbl &lt;&lt; endl;<br>    cout &lt;&lt; &quot;\t[-1]: &quot; &lt;&lt; (long)vtbl[-1] &lt;&lt; endl;<br><br>    typedef void (FuncPtr)();<br>    for (int i = 0; vtbl[i] &amp;&amp; i &lt; count; ++i)<br>    {<br>        cout &lt;&lt; &quot;\t[&quot; &lt;&lt; i &lt;&lt; &quot;]: &quot; &lt;&lt; vtbl[i] &lt;&lt; &quot; -&gt; &quot;;<br>        FuncPtr func = (FuncPtr)vtbl[i];<br>        func();<br>    }<br>}</pre><br><span style="font-family: 'Microsoft YaHei';font-size:14px;">代码解释：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">参数vtbl为虚函数表的第一个元素的地址，也就是对象中的vptr的值。参数count指的是该虚函数表中虚函数的数量。由于虚函数表中保存的信息并不全是虚函数的地址，也不是所有的虚函数表中都以NULL表示虚函数表中的函数地址已经到了尽头。所以为了让测试程序更好地运行，所以加上这一参数。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">虚函数表保存的是函数的指针，若把虚函数表当作一个数组，则要指向该数组需要一个双指针，即参数中的int <strong>vtbl，获取函数指针的值，即获取数组中元素的值，可以通过vtbl[i]来获得。<br style="background-color: inherit;"></strong></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">虚函数表中还保存着对象的类型信息，通常为了便于查找对象的类型信息，使用虚函数表中的索引（下标）为-1的位置保存该类对应的类型信息对象（即类std::type_info的对象）的地址，即保存在第一个虚函数的地址之前。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="color: rgb(255, 0, 0); background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;">2、单一继承</span></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">类的具体代码如下：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"></span></div><pre name="code" class="cpp">class Base<br>{<br>    public:<br>        Base()<br>        {<br>            mBase1 = 101;<br>            mBase2 = 102;<br>        }<br>        virtual void func1()<br>        {<br>            cout &lt;&lt; &quot;Base::func1()&quot; &lt;&lt; endl;<br>        }<br>        virtual void func2()<br>        {<br>            cout &lt;&lt; &quot;Base::func2()&quot; &lt;&lt; endl;<br>        }<br>    private:<br>        int mBase1;<br>        int mBase2;<br>};<br><br>class Derived : public Base<br>{<br>    public:<br>        Derived():<br>            Base()<br>        {<br>            mDerived1 = 1001;<br>            mDerived2 = 1002;<br>        }<br>        virtual void func2()<br>        {<br>            cout &lt;&lt; &quot;Derived::func2()&quot; &lt;&lt; endl;<br>        }<br>        virtual void func3()<br>        {<br>            cout &lt;&lt; &quot;Derived::func3()&quot; &lt;&lt; endl;<br>        }<br>    private:<br>        int mDerived1;<br>        int mDerived2;<br>};</pre><br><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">使用如下的代码进行测试：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"></span></div><pre name="code" class="cpp">int main()<br>{<br>    Derived d;<br>    char <em>p = (char</em>)&amp;d;<br>    visitVtbl((int)<em>(int<strong>)p, 3);<br>    p += sizeof(int</strong>);<br><br>    cout &lt;&lt; </em>(int<em>)p &lt;&lt; endl;<br>    p += sizeof(int);<br><br>    cout &lt;&lt; </em>(int<em>)p &lt;&lt; endl;<br>    p += sizeof(int);<br><br>    cout &lt;&lt; </em>(int<em>)p &lt;&lt; endl;<br>    p += sizeof(int);<br><br>    cout &lt;&lt; </em>(int<em>)p &lt;&lt; endl;<br><br>    return 0;<br>}</em></pre><br><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">代码解释：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">在测试代码中，最难明白的就是以下语句中的参数：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">visitVtbl((int**)(int<strong>)p, 3);</strong></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">char指针p指向了对象中的vptr，由于vptr也是一个指针，所以p应该是一个双指针，对其解引用（*p）可以获得vptr的值。然而在同一个系统中，无论是什么类型的指针，其占用的内存大小都是相同的（一般在32位系统中为4字节，64位系统中为8字节），所以可以通过以下语句获取vptr的值：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">&nbsp;(int)<em>(int<strong>)p;<br style="background-color: inherit;"></strong></em></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">该语句，进行了三件事：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">1）把char指针p进行类型转换，转换成int，即（int**)p;</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">2）通过解引用运行符“”，获得vptr的值，类型为int<em>。其实vptr本质是一个双指针，但是所有的指针占用的内存都是相等的，所以这个操作并不会导致地址值的截断。即</em>(int<strong>)p;</strong></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">3）由于vptr本质是一个双指针，所以再一次把vptr转化成一个双指针。即(int)<em>(int**)p;</em></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">注：在不少的文章中，可以看到作者把虚函数表中的项的内容当做一个整数来对待，但是本文中，我并没有这样做。因为在不同的系统（32位或64位）中的指针的位数是不同的，为了让代码能兼容32位和64位的系统，这里统一把虚函数表中的项当指针看待。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">在以后的例子若中出现相似的代码，都是相同的原理，不再解释。<br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">其运行结果如下：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img data-media-type="image" src="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/4c1593f5aac94ac1a2c294a6af4ded3f/img1.png" data-attr-org-src-id="7E6A889BBFD547D6A149B91DC3BCA349" data-attr-org-img-file="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/4c1593f5aac94ac1a2c294a6af4ded3f/img1.png" style="background-color: inherit; cursor: default; display: inline-block; margin-top: 8px; max-width: 800px;" alt=""><img src="http://img.blog.csdn.net/20150608100101009?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">根据测试的输出的结果，可以得出类Derived的对象的内存布局图如下：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img data-media-type="image" src="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/9230f5b14e9f41979508f03b1a0b4fa3/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%801.png" data-attr-org-src-id="202FAA183B654D449CAAFFD03D2D20F6" data-attr-org-img-file="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/9230f5b14e9f41979508f03b1a0b4fa3/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%801.png" style="background-color: inherit; cursor: default; display: inline-block; margin-top: 8px; max-width: 800px;" alt=""><img src="http://img.blog.csdn.net/20150608100124893?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><div><span style="font-family:Microsoft YaHei;font-size:14px;">据此，针对单一继承可以得出以下结论：</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">1）vptr位于对象的最前端。</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">2）非static的成员变量根据其继承顺序和声明顺序排在vptr的后面。</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">3）派生类继承基类所声明的虚函数，即基类的虚函数地址会被复制到派生类的虚函数表中的相应的项中。</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">4）派生类中新加入的virtual函数跟在其继承而来的virtual的后面，如本例中，子类增加的virtual函数func3被添加到func2后面。</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">5）若子类重写其父类的virtual函数，则子类的虚函数表中该virtual函数对应的项会更新为新函数的地址，如本例中，子类重写了virtual函数func2，则虚函数表中func2的项更新为子类重写的函数func2的地址。</span></div></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="color: rgb(255, 0, 0); background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;">3、多重继承</span></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">类的具体代码如下：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"></span></div><pre name="code" class="cpp">class Base1<br>{<br>    public:<br>        Base1()<br>        {<br>            mBase1 = 101;<br>        }<br>        virtual void funcA()<br>        {<br>            cout &lt;&lt; &quot;Base1::funcA()&quot; &lt;&lt; endl;<br>        }<br>        virtual void funcB()<br>        {<br>            cout &lt;&lt; &quot;Base1::funcB()&quot; &lt;&lt; endl;<br>        }<br>    private:<br>        int mBase1;<br>};<br><br>class Base2<br>{<br>    public:<br>        Base2()<br>        {<br>            mBase2 = 102;<br>        }<br>        virtual void funcA()<br>        {<br>            cout &lt;&lt; &quot;Base2::funcA()&quot; &lt;&lt; endl;<br>        }<br>        virtual void funcC()<br>        {<br>            cout &lt;&lt; &quot;Base2::funcC()&quot; &lt;&lt; endl;<br>        }<br>    private:<br>        int mBase2;<br>};<br><br>class Derived : public Base1, public Base2<br>{<br>    public:<br>        Derived():<br>            Base1(),<br>            Base2()<br>        {<br>            mDerived = 1001;<br>        }<br>        virtual void funcD()<br>        {<br>            cout &lt;&lt; &quot;Derived::funcD()&quot; &lt;&lt; endl;<br>        }<br>        virtual void funcA()<br>        {<br>            cout &lt;&lt; &quot;Derived::funcA()&quot; &lt;&lt; endl;<br>        }<br>    private:<br>        int mDerived;<br>};</pre><br><div style="line-height: 21px;"><span style="line-height: 1.5; background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;">使用如下代码进行测试：</span></span></div><div style="line-height: 21px;"><span style="line-height: 1.5; background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;"></span></span></div><pre name="code" class="cpp">int main()<br>{<br>    Derived d;<br>    char p = (char<em>)&amp;d;<br>    visitVtbl((int**)</em>(int<strong>)p, 3);<br>    p += sizeof(int</strong>);<br><br>    cout &lt;&lt; <em>(int</em>)p &lt;&lt; endl;<br>    p += sizeof(int);<br><br>    visitVtbl((int<strong>)*(int</strong>)p, 3);<br>    p += sizeof(int<strong>);<br><br>    cout &lt;&lt; <em>(int</em>)p &lt;&lt; endl;<br>    p += sizeof(int);<br><br>    cout &lt;&lt; <em>(int</em>)p &lt;&lt; endl;<br><br>    return 0;<br>}</strong></pre><br><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">其运行结果如下：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img data-media-type="image" src="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/4922316435224fc6969fabfae9ab194f/img2.png" data-attr-org-src-id="3B7FE64A42414565B0D559C8AB1EC8C2" data-attr-org-img-file="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/4922316435224fc6969fabfae9ab194f/img2.png" style="background-color: inherit; cursor: default; display: inline-block; margin-top: 8px; max-width: 800px;" alt=""></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img src="http://img.blog.csdn.net/20150608100240943?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">根据测试的输出的结果，可以得出类Derived的对象的内存布局图如下：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img data-media-type="image" src="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/c8925053af7e4b7daf02b686c277929f/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%802.png" data-attr-org-src-id="92CF76D3CC3E4B3A8799F98E4A553EBB" data-attr-org-img-file="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/c8925053af7e4b7daf02b686c277929f/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%802.png" style="background-color: inherit; cursor: default; display: inline-block; margin-top: 8px; max-width: 800px;" alt=""><img src="http://img.blog.csdn.net/20150608100301425?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">据此，针对多重继承可以得出以下结论：<br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">1）在多重继承下，一个子类拥有n-1张额外的虚函数表，n表示其上一层的基类的个数。也就是说，在多重继承下，一个派生类会有n个虚函数表。其中一个为主要实例，它与第一个基类（如本例中的Base1）共享，其他的为次要实例，与其他基类（如本例中的Base2）有关。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">2）子类新声明的virtual函数，放在主要实例的虚函数表中。如本例中，子类新声明的与Base1共享的虚函数表中。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">3）每一个父类的子对象在子类的对象保持原样性，并依次按声明次序排列。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">4）若子类重写virtual函数，则其所有父类中的签名相同的virtual函数被会被改写。如本例中，子类重写了funcA函数，则两个虚函数表中的funcA函数的项均被更新为子类重写的函数的地址。这样做的目的是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="color: rgb(255, 0, 0); background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;">4、重复继承</span></span></div><div style="line-height: 21px;"><span style="background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;">所谓的重复继承，就是某个父类被间接地重复继承了多次。<br style="background-color: inherit;"></span></span></div><div style="line-height: 21px;"><span style="background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></span></div><div style="line-height: 21px;"><span style="background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;">类的具体代码如下：</span></span></div><div style="line-height: 21px;"><span style="background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;"></span></span></div><pre code_snippet_id="693865" snippet_file_name="blog_20150613_6_6773783" name="code" class="cpp">class Base<br>{<br>    public:<br>        Base()<br>        {<br>            mBase = 11;<br>        }<br>        virtual void funcA()<br>        {<br>            cout &lt;&lt; &quot;Base::funcA()&quot; &lt;&lt; endl;<br>        }<br>        virtual void funcX()<br>        {<br>            cout &lt;&lt; &quot;Base::funcX()&quot; &lt;&lt; endl;<br>        }<br>    protected:<br>        int mBase;<br>};<br>class Base1 : public Base<br>{<br>    public:<br>        Base1():<br>            Base()<br>        {<br>            mBase1 = 101;<br>        }<br>        virtual void funcA()<br>        {<br>            cout &lt;&lt; &quot;Base1::funcA()&quot; &lt;&lt; endl;<br>        }<br>        virtual void funcB()<br>        {<br>            cout &lt;&lt; &quot;Base1::funcB()&quot; &lt;&lt; endl;<br>        }<br>    private:<br>        int mBase1;<br>};<br>class Base2 : public Base<br>{<br>    public:<br>        Base2():<br>            Base()<br>        {<br>            mBase2 = 102;<br>        }<br>        virtual void funcA()<br>        {<br>            cout &lt;&lt; &quot;Base2::funcA()&quot; &lt;&lt; endl;<br>        }<br>        virtual void funcC()<br>        {<br>            cout &lt;&lt; &quot;Base2::funcC()&quot; &lt;&lt; endl;<br>        }<br>    private:<br>        int mBase2;<br>};<br>class Derived : public Base1, public Base2<br>{<br>    public:<br>        Derived():<br>            Base1(),<br>            Base2()<br>        {<br>            mDerived = 1001;<br>        }<br>        virtual void funcD()<br>        {<br>            cout &lt;&lt; &quot;Derived::funcD()&quot; &lt;&lt; endl;<br>        }<br>        virtual void funcA()<br>        {<br>            cout &lt;&lt; &quot;Derived::funcA()&quot; &lt;&lt; endl;<br>        }<br>    private:<br>        int mDerived;<br>};</pre><br><div style="line-height: 21px;"><span style="background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;">使用如下代码进行测试：</span></span></div><div style="line-height: 21px;"><span style="background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;"></span></span></div><pre code_snippet_id="693865" snippet_file_name="blog_20150613_7_9675695" name="code" class="cpp">int main()<br>{<br>    Derived d;<br>    char <em>p = (char</em>)&amp;d;<br>    visitVtbl((int)<em>(int<strong>)p, 4);<br>    p += sizeof(int</strong>);<br><br>    cout &lt;&lt; </em>(int<em>)p &lt;&lt; endl;<br>    p += sizeof(int);<br><br>    cout &lt;&lt; </em>(int<em>)p &lt;&lt; endl;<br>    p += sizeof(int);<br><br>    visitVtbl((int**)</em>(int<strong>)p, 3);<br>    p += sizeof(int</strong>);<br><br>    cout &lt;&lt; <em>(int</em>)p &lt;&lt; endl;<br>    p += sizeof(int);<br><br>    cout &lt;&lt; <em>(int</em>)p &lt;&lt; endl;<br>    p += sizeof(int);<br><br>    cout &lt;&lt; <em>(int</em>)p &lt;&lt; endl;<br>    return 0;<br>}</pre><br><div style="line-height: 21px;"><span style="background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;">其运行结果如下：</span></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img data-media-type="image" src="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/f0d2fba130bd4a32bea497ca7fda6823/img3.png" data-attr-org-src-id="C88779477A0B4F798E1DD4DE5347F76A" data-attr-org-img-file="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/f0d2fba130bd4a32bea497ca7fda6823/img3.png" style="background-color: inherit; cursor: default; display: inline-block; margin-top: 8px; max-width: 800px;" alt=""></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img src="http://img.blog.csdn.net/20150608100537108?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">根据测试的输出的结果，可以得出类Derived的对象的内存布局图如下：<br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img src="http://img.blog.csdn.net/20150608100630991?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img data-media-type="image" src="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/4fc87f8b34ee4bcaa99696ab8ec009ac/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%803.png" data-attr-org-src-id="911038703553466A9AAB473124314A52" data-attr-org-img-file="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/4fc87f8b34ee4bcaa99696ab8ec009ac/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%803.png" style="background-color: inherit; cursor: default; display: inline-block; margin-top: 8px; max-width: 800px;" alt=""></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">据此，针对重复继承可以得出以下结论：<br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">1）重复继承后，位于继承层次顶端的父类Base分别被子类Base1和Base2继承，并被类Derived继承。所以在D中有类的对象中，存在Base1的子对象，同时也存在Base2的子对象，这两个子对象都拥有Base子对象，所以Base子对象（成员mBase）在Derived中存在两份。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">2）二义性的原因。由于在子类的对象中，存在两份父类的成员，当在Derived类中使用如下语句：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">mBase = 1;</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">就会产生歧义。因为在该对象中有两处的变量的名字都叫mBase，所以编译器不能判断究竟该使用哪一个成员变量。所以在访问Base中的成员时，需要加上域作用符来明确说明是哪一个子类的成员，如：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">Base1::mBase = 1;</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">重复继承可能并不是我们想要的，C++提供虚拟继承来解决这个问题，下面详细讲解虚拟继承。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="color: rgb(255, 0, 0); background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;">5、单一虚拟继承</span></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">具体代码如下（类的实现与重复继承中的代码相同，只是Base1的继承关系变为虚拟继承）：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"></span></div><pre code_snippet_id="693865" snippet_file_name="blog_20150613_8_3656620" name="code" class="cpp">class Base  { …… };<br>class Base1 : virtual public Base  { …… };</pre><br><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">使用如下的代码进行测试：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"></span></div><pre code_snippet_id="693865" snippet_file_name="blog_20150613_9_8684320" name="code" class="cpp">int main()<br>{<br>    Base1 b1;<br>    char <em>p = (char</em>)&amp;b1;<br>    visitVtbl((int<strong>)*(int</strong>)p, 3);<br>    p += sizeof(int<strong>);<br><br>    cout &lt;&lt; <em>(int</em>)p &lt;&lt; endl;<br>    p += sizeof(int);<br><br>    visitVtbl((int</strong>)<em>(int<strong>)p, 3);<br>    p += sizeof(int</strong>);<br><br>    cout &lt;&lt; </em>(int<em>)p &lt;&lt; endl;<br>    return 0;<br>}</em></pre><br><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">其运行结果如下：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img data-media-type="image" src="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/9f431e38799d457488ddeb8fd7820a2f/img4.png" data-attr-org-src-id="763B932AC41E460D9CCE545047EDD62A" data-attr-org-img-file="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/9f431e38799d457488ddeb8fd7820a2f/img4.png" style="background-color: inherit; cursor: default; display: inline-block; margin-top: 8px; max-width: 800px;" alt=""><img src="http://img.blog.csdn.net/20150608100806931?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">根据测试的输出的结果，可以得出类B1的<span style="line-height: 1.5;">对象的内存布局图如下：</span></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img data-media-type="image" src="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/dcd25146f1b049818b0c335f605ca043/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%804.png" data-attr-org-src-id="84DEEF43C22943D59562282EA6359A89" data-attr-org-img-file="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/dcd25146f1b049818b0c335f605ca043/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%804.png" style="background-color: inherit; cursor: default; display: inline-block; margin-top: 8px; max-width: 800px;" alt=""></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><img src="http://img.blog.csdn.net/20150608101006630?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">通过与普通的单一继承比较可以知道，单一虚继承与单一继承的对象的内存布局存在明显的不同。表现为以下的方面：</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">1）成员的顺序问题。在普通的单一继承中，基类的成员位于派生类的成员之前。而在单一虚继承中，首先是其普通基类的成员，接着是派生类的成员，最后是虚基类的成员。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">2）vptr的个数问题。在普通的单一继承中，派生类只有一个虚函数表，所以其对象只有一个vptr。而在单一虚继承中，派生类的虚函数表有n个（n为虚基类的个数）额外的虚数函数表，即总有n+1个虚函数表。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">3）派生自虚基类的派生类的虚函数表中，并不含有虚基类中的virtual函数，但是派生类重写的virtual函数会在所有虚函数表中得到更新。如本例中，第一个虚函数表中，并不含有Base::funcX的函数地址。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">注：在测试代码中，我把count传递的值为3，而结果却只调用了2个函数，可见并不是count参数限制了虚函数表的遍历。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">一个类如果内含一个或多个虚基类子对象，像Base1那样，将会被分割为两部分：一个不变区域和一个共享区域。不变区域中的数据，不管后续如何变化，总是拥有固定的偏移量（从对象的开头算起），所以这一部分可以被直接存取。共享区域所对应的就是虚基类子对象。</span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"><span style="color: rgb(255, 0, 0); background-color: inherit;">6、钻石型虚拟继承</span><br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;">具体代码如下（类的实现与重复继承中的代码相同，只是Base1和Base2的继承关系变为虚拟继承）：<br style="background-color: inherit;"></span></div><div style="line-height: 21px;"><span style="font-family:Microsoft YaHei;font-size:14px;"></span></div><pre code_snippet_id="693865" snippet_file_name="blog_20150613_10_7648735" name="code" class="cpp">class Base  { …… };<br>class Base1 : virtual public Base  { …… };<br>class Base2 : virtual public Base  { …… };<br>class Derived : public Base1, public Base2 { …… };</pre><br><div style="line-height: 21px;"><div><span style="font-family:Microsoft YaHei;font-size:14px;">使用如下的代码对对象的内存布局进行测试：</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"></span></div><pre code_snippet_id="693865" snippet_file_name="blog_20150613_11_3756231" name="code" class="cpp">int main()<br>{<br>    Derived d;<br>    char p = (char<em>)&amp;d;<br>    visitVtbl((int**)</em>(int<strong>)p, 3);<br>    p += sizeof(int</strong>);<br><br>    cout &lt;&lt; <em>(int</em>)p &lt;&lt; endl;<br>    p += sizeof(int);<br><br>    visitVtbl((int<strong>)*(int</strong>)p, 2);<br>    p += sizeof(int<strong>);<br><br>    cout &lt;&lt; <em>(int</em>)p &lt;&lt; endl;<br>    p += sizeof(int);<br><br>    cout &lt;&lt; <em>(int</em>)p &lt;&lt; endl;<br>    p += sizeof(int);<br><br>    visitVtbl((int</strong>)<em>(int<strong>)p, 2);<br>    p += sizeof(int</strong>);<br><br>    cout &lt;&lt; </em>(int<em>)p &lt;&lt; endl;<br>    return 0;<br>}</em></pre><br><div><span style="font-family:Microsoft YaHei;font-size:14px;">其运行结果如下：</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><img data-media-type="image" src="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/4636272b97ab4bfa9f45a778d3b6f705/img5.png" data-attr-org-src-id="EF207478D73341E39BD70A1E3F0F3466" data-attr-org-img-file="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/4636272b97ab4bfa9f45a778d3b6f705/img5.png" style="background-color: inherit; cursor: default; display: inline-block; margin-top: 8px; max-width: 800px;" alt=""><img src="http://img.blog.csdn.net/20150608101025553?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">根据测试的输出的结果，可以得出类Derived的对象的内存布局图如下：<br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><img data-media-type="image" src="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/deb57e76663a41bba630282c5801d52a/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%805.png" data-attr-org-src-id="B1B49F36399A489B9E9780F1248A89C2" data-attr-org-img-file="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/deb57e76663a41bba630282c5801d52a/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%805.png" style="background-color: inherit; cursor: default; display: inline-block; margin-top: 8px; max-width: 800px;" alt=""></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><img src="http://img.blog.csdn.net/20150608100936262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">使用虚继承后，在派生类的对象中只存在一份的Base子对象，从而避免了二义性。由于是多重继承，且有一个虚基类（Base），所以Derived类拥有三个虚函数表，其对象存在三个vptr。如上图所示，第一个虚函数表是由于多重继承而与第一基类（Base1）共享的主要实例，第二个虚函数表是与其他基类（Base2）有关的次要实例，第三个是虚基类的虚函数表。</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">类Derived的成员与Base1中的成员排列顺序相同，首先是以声明顺序排列其普通基类的成员，接着是派生类的成员，最后是虚基类的成员。</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">派生自虚基类的派生类的虚函数表中，也不含有虚基类中的virtual函数，派生类重写的virtual函数会在所有虚函数表中得到更新。</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">在类Derived的对象中，Base（虚基类）子对象部分为共享区域，而其他部分为不变区域。</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="color: rgb(255, 0, 0); background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;">7、关于虚析构函数的说明</span></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">上面的的例子中，为了让测试程序正常的运行，我们都没有定义一个virtual的析构函数，但是这并不表示它不是本文的讨论内容。</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">若基类声明了一个virtual析构函数，则其派生类的析构函数会更新其所有的虚函数表中的析构函数的项，把该项中的函数地址更新为派生类的析构函数的函数地址。因为当基类的析构函数为virtual时，若用户不显示提供一个析构函数，编译器则会自动合成一个，所以若基类声明了一个virtual析构函数，则其派生 类中必然存在一个virtual的析构函数，并用这个virutal析构函数更新虚函数表。</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="color:#ff0000;background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;">8、类型信息</span></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">在C++中，可以使用关键字typeid来获得一个对象所对应的类型信息，例如，以下代码：</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">Base p;</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">……</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">cout &lt;&lt; typeid(<em>p).name() &lt;&lt; endl;</em></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">由于p是一个指针，它可以指向一个Base的对象，若者是Base的派生类，那么我们如何知道p所指的对象是什么类型呢？</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">通过观察2-6节中的例子的输出，可以发现，无论一个类有多少个虚函数，其下标为-1的项的值（即<span style="line-height: 21px;">type_info对象的地址</span>）都是相等的<span style="line-height: 21px;">，即它们都指向相同的</span><span style="line-height: 21px;">type_info对象</span>。所以<span style="line-height: 21px;">无论使用基类还是派生类的指针指向一个对象，都能根据对象的vptr指向的虚函数表正确地获得该对象所属的类的type_info对象，从而分辨出指针所指对象的真实类型。</span>例如对于如下的测试代码（类的关系和实现是第6节中的钻石型虚拟继承）：</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"></span></div><pre code_snippet_id="693865" snippet_file_name="blog_20150613_12_1292187" name="code" class="cpp">int main()<br>{<br>    Derived d;<br>    Base basePtr = &amp;d;<br>    Base1 <em>base1Ptr = &amp;d;<br>    Base2 </em>base2Ptr = &amp;d;<br>    Derived <em>derivedPtr = &amp;d;<br>    cout &lt;&lt; typeid(</em>basePtr).name() &lt;&lt; endl;<br>    cout &lt;&lt; typeid(<em>base1Ptr).name() &lt;&lt; endl;<br>    cout &lt;&lt; typeid(</em>base2Ptr).name() &lt;&lt; endl;<br>    cout &lt;&lt; typeid(<em>derivedPtr).name() &lt;&lt; endl;<br>    return 0;<br>}</em></pre><br><div><span style="font-family:Microsoft YaHei;font-size:14px;">其输出结果如下</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><img data-media-type="image" src="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/79fac7e3607c4515bbdc535d33e12513/img6.png" data-attr-org-src-id="5C18F4FFE22349D28ADF3D6B393D1093" data-attr-org-img-file="file:///C:/Users/Administrator/AppData/Local/YNote/data/ljianhui2012@163.com/79fac7e3607c4515bbdc535d33e12513/img6.png" style="background-color: inherit; cursor: default; display: inline-block; margin-top: 8px; max-width: 800px;" alt=""></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><img src="http://img.blog.csdn.net/20150608101146454?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">从上面的运行可以看出，一个派生类的对象，无论被其任何基类的指针指向，都能通过typeid正确地获得其所指的对象的真实类型。</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">运行结果解释：</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">要理解运行的结果，就要理解当把一个派生类对象指针赋值给其基类指针时会发生什么样的行为。<span style="line-height: 1.5;">当使用基类的指针指向一个派生类的对象时，编译器会安插相应的代码，调整指针的指向，使基类的指针指向派生类对象中其对应的基类子对象的起始处。</span></span></div><div><span style="line-height: 1.5;"><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></span></div><div><span style="line-height: 1.5;"><span style="font-family:Microsoft YaHei;font-size:14px;">所以通过测试代码中的指针赋值，产生如下的结果：</span></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">basePtr 指向了对象d中的Base子对象的地址起始处，即指向了Base::vptr</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">base1Ptr 指向了对象d中的Base1子对象的地址起始处，即指向了Base1::vptr<br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">base2Ptr 指向了对象d中的Base2子对象的地址起始处，即指向了Base2::vptr<br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">derivedPtr 指向了对象d的地址起始处，即指向了Base1::vptr</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br></span></div><div><span style="line-height: 1.5;"><span style="font-family:Microsoft YaHei;font-size:14px;">即现在这些指针都指向了对应的类型的子对象，且其都包括一个vptr，所以就可以通过虚函数表中的第-1项的type_info对象的地址来获取type_info对象，从而获得类型信息。而这些地址值都是相同的，即指向同一个type_info对象，且该type_info对象显示该对象的类型为Derived，也就能正确地输出其类型信息。</span></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="color:#ff0000;background-color: inherit;"><span style="font-family:Microsoft YaHei;font-size:14px;">9、虚函数调用的原理</span></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">我们知道，在C++中使用指向对象的指针或引用才能触发虚函数的调用，产生多态的结果。例如对于如下的代码片断：</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">Base p;</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">……</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">p-&gt;vfunc(); // vfunc是Base中声明的virtual函数</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">由于指针p可以指向一个Base的对象，也可以指向Base的派生类的对象，而编译器在编译时并不知道p所指向的真实对象到底是什么，那么究竟如何判断呢？</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">从各种的C++对象的内存分布中可以看到，尽管虚函数表中的虚函数地址可能被更新（派生类重写基类的virtual函数）或添加新的项（派生类声明新的virtual函数），但是一个相同签名的虚函数在虚函数表中的索引值却是不变的。所以无论p指向的是Base的对象，还是Base的派生类的对象，其virtual函数vfunc在虚函数表中的索引是不变的（均为1）。<br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">在了解了C++对象的内存布局后，就能轻松地回答这个问题了。因为在编译时，编译器根本无需判断p所指向的具体对象是什么，而是根据指针p所指向的对象的Base子对象中的虚函数表来实现函数调用的。编译器可能会把virtual函数调用的代码修改为如下的伪代码：</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">(*p-&gt;vptr[1])(p); // 假设vfunc函数在虚函数表中的索引值为1，参数p为this指针</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br style="background-color: inherit;"></span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;">若p指向的是一个Base的对象，则调Base的虚函数表中索引值为1的函数。若p指向的是一个Base的派生类的对象，则调用Base的派生类对象的Base子对象的虚函数表中的索引值为1的函数。这样便实现了多态 。这种函数调用是根据指针p所指的对象的虚函数表来实现的，在编译时由于无法确定指针p所指的真实对象，所以无法确定真实要调用哪一个函数，只有在运行时根据指针p所指的对象来动态决定。所以说，虚函数是在运行时动态绑定的，而不是在编译时静态绑定的。</span></div><div><span style="font-family:Microsoft YaHei;font-size:14px;"><br></span></div></div><div style="font-family: 微软雅黑; font-size: 14px; line-height: 21px;"><br style="background-color: inherit;"></div><br></div>


<p>转自CDSN<a href="http://blog.csdn.net/ljianhui/article/details/46408645" target="_blank" rel="external">阅读原文</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/03/C++对象模型之简述C++对象的内存布局/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="nosix">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/03/C++对象模型之简述C++对象的内存布局/" itemprop="url">C++对象模型之简述C++对象的内存布局</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-05-03T10:05:48+08:00">
                2015-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post"><br><div><span style="font-size:18px;">在C++中，有两种类的成员变量：static和非static，有三种成员函数：static、非static和virtual。那么，它们如何影响C++的对象在内存中的分布呢？ 当存在继承的情况下，其内存分布又是如何呢？<br></span> <div><span style="font-size:18px;"><br></span> <div><span style="font-size:18px;">下面就一个非常简单的类，通过逐渐向其中加入各种成员，来逐一分析上述两种成员变量及三种成员函数对类的对象的内存分布的影响。<br></span> <div><span style="font-size:18px;"><br> 注：以下的代码的测试结果均是基于Ubuntu 14.04 64位系统下的G++ 4.8.2，若在其他的系统上或使用其他的编译器，可能会运行出不同的结果。<br></span> </div></div></div></div><div><span style="font-size:18px;"><br></span> </div><div><span style="font-size:18px;color:red;">1、含有非static成员变量及成员函数的类的对象的内存分布</span><span style="font-size:18px;"><br> </span><div><span style="font-size:18px;">类Persion的定义如下： </span><br> <pre code_snippet_id="672528" snippet_file_name="blog_20150522_1_9940117" name="code" class="cpp">class Person<br>{<br>    public:<br>        Person():mId(0), mAge(20){}<br>        void print()<br>        {<br>            cout &lt;&lt; &quot;id: &quot; &lt;&lt; mId<br>                 &lt;&lt; &quot;, age: &quot; &lt;&lt; mAge &lt;&lt; endl;<br>        }<br>    private:<br>        int mId;<br>        int mAge;<br>}; </pre><br><span style="font-size:18px;">Person类包含两个非static的int型的成员变量，一个构造函数和一个非static成员函数。为弄清楚该类的对象的内存分布，对该类的对象进行一些操作如下： </span><br> <div><div><pre code_snippet_id="672528" snippet_file_name="blog_20150522_2_3401017" name="code" class="cpp">int main()<br>{<br>    Person p1;<br>    cout &lt;&lt; &quot;sizeof(p1) == &quot; &lt;&lt; sizeof(p1) &lt;&lt; endl;<br>    int <em>p = (int</em>)&amp;p1;<br>    cout &lt;&lt; &quot;p.id == &quot; &lt;&lt; <em>p &lt;&lt; &quot;, address: &quot;  &lt;&lt; p &lt;&lt; endl;<br>    ++p;<br>    cout &lt;&lt; &quot;p.age == &quot; &lt;&lt; </em>p &lt;&lt; &quot;, address: &quot; &lt;&lt; p &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br><br>    Person p2;<br>    cout &lt;&lt; &quot;sizeof(p2) == &quot; &lt;&lt; sizeof(p1) &lt;&lt; endl;<br>    p = (int<em>)&amp;p2;<br>    cout &lt;&lt; &quot;p.id == &quot; &lt;&lt; </em>p &lt;&lt; &quot;, address: &quot; &lt;&lt; p &lt;&lt; endl;<br>    ++p;<br>    cout &lt;&lt; &quot;p.age == &quot; &lt;&lt; <em>p &lt;&lt; &quot;, address: &quot; &lt;&lt; p &lt;&lt; endl;<br>    return 0;<br>} </em></pre><br><span style="font-size:18px;">其运行结果如下： </span><br> <div><div><div><div>&nbsp;<img src="http://img.blog.csdn.net/20150522023309556?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br> <div><br> <div><div><div><div><span style="font-size:18px;">从上图可以看到类的对象的占用的内存均为8字节，使用普通的int＊指针可以遍历输出对象内的非static成员变量的值，且两个对象中的相同的非static成员变量的地址各不相同。<br></span> <span style="font-size:18px;"><br></span> </div><div><span style="font-size:18px;">据此，可以得出结论，在C++中，非static成员变量被放置于每一个类对象中，非static成员函数放在类的对象之外，且非static成员变量在内存中的存放顺序与其在类内的声明顺序一致。即person对象的内存分布如下图所示： </span><br> <div><img src="http://img.blog.csdn.net/20150522023352769?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br> </div></div></div><br> </div><br> </div></div></div></div></div></div></div></div></div></div><div><span style="font-size:18px;color:red;">2、含有static和非static成员变量和成员函数的类的对象的内存分布<br> </span><span style="font-size:18px;"> </span><div><span style="color:red;"><span style="color:black;"><span style="font-size:18px;"><br> 向Person类中加入一个static成员变量和一个static成员函数，如下：</span><br></span></span><pre code_snippet_id="672528" snippet_file_name="blog_20150522_3_7177560" name="code" class="cpp">class Person<br>{<br>     public:<br>         Person():mId(0), mAge(20){ ++sCount; }<br>         ~Person(){ –sCount; }<br>         void print()<br>         {<br>             cout &lt;&lt; &quot;id: &quot; &lt;&lt; mId<br>                  &lt;&lt; &quot;, age: &quot; &lt;&lt; mAge &lt;&lt; endl;<br>         }<br>         static int personCount()<br>         {<br>             return sCount;<br>         }<br>     private:<br>         static int sCount;<br>         int mId;<br>         int mAge;<br>}; </pre><br><span style="font-size:18px;">测试代码不变，与第1节中的代码相同。其运行结果不变，与第1节中的运行结果相同。<br> </span><div><span style="font-size:18px;"><br></span><div><span style="font-size:18px;"> 据此，可以得出：static成员变量存放在类的对象之外，static成员函数也放在类的对象之外。<br></span><div><span style="font-size:18px;"><br>其内存分布如下图所示：</span><br></div></div><div><img src="http://img.blog.csdn.net/20150522023400565?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br></div></div></div></div><span style="font-size:18px;color:red;">3、</span><span style="font-family:微软雅黑;font-size:18px;color:#000000;background-color:#FFFFFF;font-style:normal;font-weight:normal;text-align:left;"><span style="color:black;"><span style="color:red;">加入virtual成员函数的类的对象的内存分布</span><br> </span></span><span style="font-size:18px;">  </span><div><span style="font-size:18px;"><br>在Person类中加入一个virtual函数，并把前面的print函数修改为函数，如下： </span><br> <pre code_snippet_id="672528" snippet_file_name="blog_20150522_4_3212754" name="code" class="cpp">class Person<br>{<br>    public:<br>        Person():mId(0), mAge(20){ ++sCount; }<br>        static int personCount()<br>        {<br>            return sCount;<br>        }<br><br>        virtual void print()<br>        {<br>            cout &lt;&lt; &quot;id: &quot; &lt;&lt; mId<br>                 &lt;&lt; &quot;, age: &quot; &lt;&lt; mAge &lt;&lt; endl;<br>        }<br>        virtual void job()<br>        {<br>            cout &lt;&lt; &quot;Person&quot; &lt;&lt; endl;<br>        }<br>        virtual ~Person()<br>        {<br>            –sCount;<br>            cout &lt;&lt; &quot;~Person&quot; &lt;&lt; endl;<br>        }<br><br>    protected:<br>        static int sCount;<br>        int mId;<br>        int mAge;<br>};</pre><br></div><div><span style="font-size:18px;">为了查看类的对象的内存分布，对类的对象执行如下的操作代码，如下： </span><br><div> <pre code_snippet_id="672528" snippet_file_name="blog_20150522_5_1903251" name="code" class="cpp">int main()<br>{<br>    Person person;<br>    cout &lt;&lt; sizeof(person) &lt;&lt; endl;<br>    int p = (int<em>)&amp;person;<br>    for (int i = 0; i &lt; sizeof(person) / sizeof(int); ++i, ++p)<br>    {<br>        cout &lt;&lt; </em>p &lt;&lt; endl;<br>    }<br>    return 0;<br>} </pre><br><div><div><span style="font-size:18px;">其运行结果如下： </span><br><div> <img src="http://img.blog.csdn.net/20150522023520285?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br> </div><div><br><div><span style="font-size:18px;">从上图可以看出，加virtual成员函数后，类的对象的大小为16字节，增加了8。通过int＊指针遍历该对象的内存，可以看到，最后两行显示的是成员数据的值。<br></span><div><span style="font-size:18px;"><br></span><div><span style="font-size:18px;">C++中的虚函数是通过虚函数表（vtbl）来实现，每一个类为每一个virtual函数产生一个指针，放在表格中，这个表格就是虚函数表。每一个类对象会被安插一个指针（vptr），指向该类的虚函数表。vptr的设定和重置都由每一个类的构造函数、析构函数和复制赋值运算符自动完成。<br></span><div><span style="font-size:18px;"><br></span><div><div><span style="font-size:18px;">由于本人的系统是64位的系统，一个指针的大小为8字节，所以可以推出，在本人的环境中，类的对象的安插的vptr放在该对象所占内存的最前面。其内存分布图如下：<br></span><div><span style="font-size:18px;">注：虚函数的顺序是按虚函数定义顺序定义的，但是它还包含其他的一些字段，本人还未明白它是什么，在下一节会详细说明虚函数表的内容。</span><br></div></div><div><img src="http://img.blog.csdn.net/20150522023548880?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br><div><span style="font-size:18px;color:red;">4、虚函数表（vtbl）的内容及</span><span style="font-size:18px;color:red;">函数指针存放顺序</span><span style="font-size:18px;"><br></span><div><span style="font-size:18px;">在第3节中，我们可以知道了指向虚函数表的指针（vptr）在类中的位置了，而函数表中的数据都是函数指针，于是便可利用这点来遍历虚函数表，并测试出虚函数表中的内容。<br></span><div><span style="font-size:18px;"><br></span><div><span style="font-size:18px;">测试代码如下：</span><br><pre code_snippet_id="672528" snippet_file_name="blog_20150522_6_7971463" name="code" class="cpp">typedef void (<em>FuncPtr)();<br>int main()<br>{<br>    Person person;<br>    int <strong>vtbl = (int</strong>)</em>(int<strong>)&amp;person;<br>    for (int i = 0; i &lt; 3 &amp;&amp; <em>vtbl != NULL; ++i)<br>    {<br>        FuncPtr func = (FuncPtr)</em>vtbl;<br>        func();<br>        ++vtbl;<br>    }<br><br>    while (<em>vtbl)<br>    {<br>        cout &lt;&lt; &quot;</em>vtbl == &quot; &lt;&lt; *vtbl &lt;&lt; endl;<br>        ++vtbl;<br>    }<br>    return 0;<br>}</strong></pre><br><div><div><span style="font-size:18px;">代码解释：<br>由于虚函数表位于对象的首位置上，且虚函数表保存的是函数的指针，若把虚函数表当作一个数组，则要指向该数组需要一个双指针。我们可以通过如下方式获取Person类的对象的地址，并转化成int指针：</span></div><div><div><div><div><pre code_snippet_id="672528" snippet_file_name="blog_20150522_7_6241129" name="code" class="cpp">Person person;<br>int <strong>p = (int</strong>)&amp;person;</pre><br><div><span style="font-size:18px;">再通过如下的表达式，获取虚函数表的地址：</span><br><div><div><div>&nbsp;<pre code_snippet_id="672528" snippet_file_name="blog_20150522_8_8589213" name="code" class="cpp">int <strong>vtbl = (int</strong>)<em>p;</em></pre><br><span style="font-size:18px;">然后，通过如下语句获得虚函数表中函数的地址，并调用函数。</span><br></div></div></div></div></div></div><pre code_snippet_id="672528" snippet_file_name="blog_20150522_9_6543235" name="code" class="cpp">FuncPtr func = (FuncPtr)vtbl;<br>func();</pre><br><div><div><span style="font-size:18px;">最后，通过++vtbl可以得到函数表中下一项地址，从而遍历整个虚函数表。<br></span></div><span style="font-size:18px;"><br></span></div></div><div><span style="font-size:18px;">其运行结果如下图所示：</span><br><div><img src="http://img.blog.csdn.net/20150522023651170?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><div><br><div><div><span style="font-size:18px;">从上图可以看出，遍历虚函数表，并根据虚函数表中的函数地址调用函数，它先调用print函数，再调用job函数，最后调用析构函数。函数的调用顺序与Person类中的虚函数的定义顺序一致，其内存分布与第3节中的对象内存分布图相一致。从代码和运行结果，可以看出，虚函数表以NULL标志表的结束。但是虚函数表中还含有其他的数据，本人还没有清楚其作用。<br></span><div><span style="font-size:18px;"><br></span><div><span style="font-size:18px;color:red;">5、继承对于类的对象的内存分布的影响</span><span style="font-size:18px;"><br></span><div><span style="font-size:18px;">本文并不打算详细地介绍继承对对象的内存分布的影响，也不介绍虚函数的实现机制。这里主要给出一个经过本人测试的大概的对象内存模型，由于代码较多，不一一贴出。假设所有的类都有非static的成员变量和成员函数、static的成员变量及成员函数和virtual函数。<br></span><div><div><div><span style="font-size:18px;">1）单继承（只有一个父类）<br>类的继承关系为：class Derived : public Base</span><br></div><div><img src="http://img.blog.csdn.net/20150522023659996?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><div><span style="font-size:18px;">Derived类的对象的内存布局为：虚函数表指针、Base类的非static成员变量、Derived类的非static成员变量。<br><br></span></div></div></div><div><div><div><span style="font-size:18px;">2）多重继承（多个父类）<br>类的继承关系如下：class Derived : public Base1, public Base2</span><br></div><div><img src="http://img.blog.csdn.net/20150522023810465?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><div><span style="font-size:18px;">Derived类的对象的内存布局为：基类Base1子对象和基类Base2子对象及Derived类的非static成员变量组成。基类子对象包括其虚函数表指针和其非static的成员变量。<br><br></span></div></div></div><div><div><div><span style="font-size:18px;">3）重复继承（<span style="color:#000000;font-size: 16px;">继承的多个父类中其父类有相同的超类</span>）<br></span><div><span style="font-size:18px;">类的继承关系如下：<br></span><div><span style="font-size:18px;">class Base1 : public Base<br></span><div><span style="font-size:18px;">class Base2:&nbsp; public Base<br></span><div><span style="font-size:18px;">class Derived : public Base1, public Base2</span><br><div><img src="http://img.blog.csdn.net/20150522023800275?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><span style="font-size:18px;">Derived类的对象的内存布局与多继承相似，但是可以看到基类Base的子对象在Derived类的对象的内存中存在一份拷贝。这样直接使用Derived中基类Base的相关成员时，就会引发歧义，可使用多重虚拟继承消除之。<br></span></div></div></div></div></div></div><span style="font-size:18px;"><br></span></div><span style="font-size:18px;">4）<span style="color:#000000;font-size: 16px;">多重虚拟继承（使用virtual方式继承，为了保证继承后父类的内存布局只会存在一份</span>）<br></span></div></div></div></div></div></div></div><div><div><span style="font-size:18px;">类的继承关系如下：<br>class Base1 : virtual public Base<br>class Base2:&nbsp; virtual public Base<br>class Derived : public Base1, public Base2</span><br></div><div><img src="http://img.blog.csdn.net/20150530005022692?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGppYW5odWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><span style="font-size:18px;">Derived类的对象的内存布局与重复继承的类的对象的内存分布类似，但是基类Base的子对象没有拷贝一份，在对象的内存中仅存在在一个Base类的子对象。但是它的非static成员变量放置在对象的末尾处。<br></span></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><div><span style="font-size:18px;"><br></span></div><span style="font-size: 18px;">关于继承对对象的内存布局的影响以及虚函数的实现机制的详细介绍，请参阅——<a href="http://blog.csdn.net/ljianhui/article/details/46408645" target="_blank" rel="external"><span style="color:#ff0000;">C++对象模型之详述C++对象的内存布局</span></a></span><br><br></div>


<p>转自CDSN<a href="http://blog.csdn.net/ljianhui/article/details/45903939" target="_blank" rel="external">阅读原文</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="nosix" />
          <p class="site-author-name" itemprop="name">nosix</p>
           
              <p class="site-description motion-element" itemprop="description">以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">85</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">75</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/nosix1992" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">nosix</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>


<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>